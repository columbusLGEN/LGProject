//
//  NestClass.swift
//  Chapter2
//
//  Created by Peanut Lee on 2018/2/5.
//  Copyright © 2018年 LG. All rights reserved.
//

import Foundation
class NestClass: ViewController {
    override func viewDidLoad() {
        
        /// MARK: 一.嵌套类型
        /// 嵌套类型实践 & 引用嵌套类型
        
        /// MARK: 三.协议
        /// 1.协议语法
        
        /// 2.方法要求
        
        /// 3.Mutating（在方法内部改变方法所属的实例） 方法要求
        
        /// 4.构造器要求
        /// * final 修饰的类不能有子类
        /// * required 修饰的方法为 遵守该协议的类必须实现的
        
        /// 5.协议作为类型
        /// 协议可以和其他普通类型一样使用
        /// 声明为 某协议类型的常量/变量 可以接受任何遵循了该协议的类型的实例 赋值
        
        /// 6.代理模式
        
        /// 7.通过扩展添加协议一致性
        /// * 通过扩展遵循协议并符合协议，和在原始定义中遵循并符合协议的效果完全相同
        
        /// 8.通过扩展遵守协议
        
        /// 9.协议类型的集合

        /// 10.协议的继承
        
        /// 11.类类型专属协议
        /// * 可以在协议的继承列表中使用 class（第一个出现） 关键字修饰，以表示协议只能被类遵守，不适用于枚举和结构体
        
        /// 12.协议合成
        /// * 协议合成不会生成新的协议、永久的协议，而是将多个协议中的要求合成到一个只在局部作用域有效的临时协议中
        
        /// 13.检查协议一致性
        /// is 检查类型是否符合某个协议
        /// as? 当实例符合某个协议时，返回类型为协议类型的可选值，否则返回nil
        /// as! 将实例强制向下转换为某个协议类型
        
        /// 14.可选的协议要求
        /// @objc
        /// optional
        
        /// 15.协议扩展
        /**
            通过协议扩展为协议要求提供的默认实现和可选的协议要求不同。虽然在这两种情况下，
            遵循协议的类型都无需自己实现这些要求，但是通过扩展提供的默认实现可以直接调用，而无需使用可选链式调用。
         */
        
        /**
         如果多个协议扩展都为同一个协议要求提供了默认实现，而遵循协议的类型又同时满足这些协议扩展的限制条
         件，那么将会使用限制条件最多的那个协议扩展提供的默认实现。
         */
    }
    
    
}

extension NestClass{
    /// MARK: 二.扩展
    /// * 扩展可以为一个类型添加功能，但是不能重写已有的功能
    /// 1.扩展语法
    /// 使用关键字 extension 声明
    
    /// 2.计算型属性
    /// 扩展可以添加新的计算型属性，但是不能添加存储型属性，也不可以为现有属性添加属性观察器
    
    /// 3.构造器
    /// 扩展不能添加 指定构造器 和析构器
    /// 使用扩展提供的新构造器，要确保构造过程能够让实例完全初始化
    
    /// 4.方法
    
    /// 5.下标
    
    /// 6.嵌套类型
    
    
}
//extension NestClass: SomeProtocol{
//
//}

