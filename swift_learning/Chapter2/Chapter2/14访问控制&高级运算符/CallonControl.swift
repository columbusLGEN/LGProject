//
//  CallonControl.swift
//  Chapter2
//
//  Created by Peanut Lee on 2018/2/27.
//  Copyright © 2018年 LG. All rights reserved.
//

import Foundation

class CallonControl: ViewController {
    override func viewDidLoad() {
        
        /// MARK: 访问控制
        
        /// 1.模块和源文件 --> 访问控制基于这两个概念
        
        /// 2.访问级别 (类,结构体,枚举 简称 实体)
        /// * Swift 提供了5中不同的访问级别
            /// 开放访问 公开访问
            /// 内部访问
            /// 文件私有访问
            /// 私有访问
        
        /// * 访问级别的基本原则: 不可以在实体中定义 访问级别更低(风严格)的实体
        /// * 实体默认的访问级别是internal
        /// * 当需要把某个实体当做框架的API时,需要显式为其制定访问级别为开放访问或者公开访问
        
        /// 3.访问控制语法
        /// open, public, internal, filepart, private
        
        /// 4.自定义类型
        /// * 一个公开类型的成员默认是内部仿问级别. 想要定义为公开访问级别,需要显示指定
        
            /// 元组类型
            /// * 元组的访问级别由元组中访问级别最严格的类型来决定.
        
            /// 函数类型
            /// * 函数的访问级别由访问级别最严格的参数类型或者返回值类型决定.但是,如果这种访问级别不符合函数的定义所在环境的默认访问级别,那么久需要显示指定该函数的访问级别
        
            /// 枚举类型
            /// 嵌套类型
        
        /// 5.子类
        /// * 子类的访问级别不得高于父类的访问级别, 即子类不能比父类更公开
        /// * 此外,可以在符合当前访问级别的条件下重写任意类成员 并修改其访问级别(比如重新制定为更高的访问级别)
        
        /// 6.常量,变量,属性,下标
        
        /// 7.构造器
        
        /// 8.协议
        /// * 协议中的每一个要求都和该协议有相同的访问级别
        
        /// 9.扩展
        /// * 扩展成员具有和原始类型成员一致的访问级别,或者可以显示指定扩展的访问级别
        /// * 如果通过扩展来采纳协议,则不能显示指定该扩展的访问级别
        
        /// 10.泛型
        
        /// 11.类型别名
        /// 你定义的任何类型别名都会被当做不同的的类型,以便进行访问控制,而类型别名的访问级别不能高于其表示的类型的访问级别
        
        /// MARK: 高级运算符
        /// 1.位运算符
        /// * 位运算符可以操作数据结构中的每一个比特位.通常被用底层开发中,比如图形处理和创建设备驱动.
            /// 1.1按位取反运算符 (~) 前缀运算符
            /// 1.2按位于运算符 (&)
            /// 1.3按位或运算符 (|)
            /// 1.4按位异或运算符 (^)
            /// 1.5按位左移运算符(<<),右移运算符(>>)
                /// * 对无符号整数进行移位的规则如下:
                    /// 1 已经存在的位按指定的位数进行左移右移
                    /// 2 任何因移动而超出整形存储范围的位都会被丢弃
                    /// 3 用 0 来填充移位后产生的空白位
                /// * 有符号整数的移位运算 --> 通常使用第一个比特位来表示符号: 0代表整数;1代表负数
                    /// * 有符号整数右移运算的额外规则:
                    /// 当对证书进行按位右移运算时,遵循与无符号整数相同的规则,但是对于移位产生的空白为使用符号位填充,而不是0;这个行为可以确保有符号整数的符号位不会因为右移运算而改变,这通常被称为算术移位
        
        
        /// 2.溢出运算符
        /// 在swif中,默认情况下向一个整数赋予超过它的容量的值时,会报错,而不是生成一个无效的数.
        /// 然而,也可以选择让西戎在数值溢出的时候采取截取处理,而非报错. 使用溢出运算符让系统支持溢出运算
        
        /// 溢出加法 &+
        /// 溢出减法 &-
        /// 溢出乘法 &*
        
        /// 对于无符号和有符号的整形数值,当出现上溢时,它们会从能容纳的最大数变成最小数,当出现下溢时,它们从能容纳的最小数变成最大数
        
        /// 3.优先级和结合性
        /// * 相对于C语言和Objective-C,swift 的运算符优先级和结合性更加简洁和可预测.但是,这就意味着它们相较于C语言以及其衍生语言并不是完全一致.
        
        /// 4.运算符函数
        /// *运算符重载: 类和结构体可以为现有的运算符提供自定义实现
        
        /// 中缀运算符直接重写即可: static func + (left: someType, right: someType) - someType{}
        /// 前缀和后缀运算符需要在声明运算符函数的时候加上 prefix 和 postfix 修饰符
        
        /// 重载复合赋值运算符(例如 += )时,需要把左边的参数声明为 inout 类型,因为其在运算时,自身的值被改变了
        /// static func += (left: inout someType, rifht: someType) { left = left + right}
        /// *注意: 默认的赋值运算符(=) 和 三目运算符(a:b?c) 进行重载
        
        /// 等价运算符
        
        /// 5.自定义运算符
        
        /// * 新的运算符要使用 operator 关键字在全局作用域内进行定义, 同时还要指定 prefix , infix 或者 postfix 修饰符
        /// 例如: prefix operator +++ {}
        
        /// 自定义中缀运算符的优先级
        /// 每个自定义中缀运算符都属于某个优先级组
        /// * 关于swift 标准库提供的运算符,以及完整的运算符优先级组合结合性设置,参考 Swift Standard Library Operators Reference
        
        /// * 当定义前缀和后缀运算符的时候后,虽然没有指定优先级,但是,当对同一个值同时使用前缀和后缀运算符,则后缀运算符会先参与运算
        
    }
    
}
