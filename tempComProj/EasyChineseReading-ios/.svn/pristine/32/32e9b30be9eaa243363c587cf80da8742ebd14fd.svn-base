//
//  ECRDownloadManager.m
//  EasyChineseReading-ios
//
//  Created by Peanut Lee on 2017/11/6.
//  Copyright © 2017年 retech. All rights reserved.
//

/// epub, hypermedia, pdf

#import "ECRDownloadManager.h"
#import "ECRDesidCodeMgr.h"

@interface ECRDownloadManager ()

@property (strong,nonatomic) NSFileManager *fileMgr;//

@property (strong,nonatomic) NSURLSessionDownloadTask *downloadTask;//

@property (strong,nonatomic) NSURLSessionDataTask *dataTask;//

@property (copy,nonatomic) void (^rg_progress)(NSProgress * _Nonnull downloadProgress);//

@property (strong,nonatomic) AFURLSessionManager *manager;//
/** 文件的总长度 */
@property (nonatomic, assign) NSInteger fileLength;
/** 当前下载长度 */
@property (nonatomic, assign) NSInteger currentLength;
/** 文件句柄对象 */
@property (nonatomic, strong) NSFileHandle *fileHandle;

@end

@implementation ECRDownloadManager

// 对链接DES解密
+ (NSString *)desUncodeWithDesString:(NSString *)desString key:(NSString *)key{
    return [[self sharedInstance] desUncodeWithDesString:desString key:key];
}
- (NSString *)desUncodeWithDesString:(NSString *)desString key:(NSString *)key{
    return [ECRDesidCodeMgr decryptUseDES:desString key:key];
}

+ (BOOL)fileIsExist:(NSString *)path{
    return [[self sharedInstance] fileIsExist:path];
}
- (BOOL)fileIsExist:(NSString *)path{
    return [self.fileMgr fileExistsAtPath:path];
}

// MARK: 取消正在进行的下载操作
+ (void)cancelDownloadTask{
    [[self sharedInstance] cancelDownloadTask];
}
- (void)cancelDownloadTask{
    [_dataTask cancel];
    // 清空长度
    self.currentLength = 0;
    self.fileLength = 0;
    
    // 关闭fileHandle
    [self.fileHandle closeFile];
    self.fileHandle = nil;
}

#pragma mark - 下载操作
+ (void)downloadWithURLString:(NSString *)URLString fileName:(NSString *)fileName progress:(ECRDownloadManagerProgress)progress success:(ECRDownloadManagerAbsuloteSuccess)success failure:(ECRDownloadManagerAbsuloteFailure)failure{
    [[self sharedInstance] downloadWithURLString:URLString fileName:fileName progress:progress success:success failure:failure];
}

- (void)downloadWithURLString:(NSString *)URLString fileName:(NSString *)fileName progress:(ECRDownloadManagerProgress)progress success:(ECRDownloadManagerAbsuloteSuccess)success failure:(ECRDownloadManagerAbsuloteFailure)failure{
    
    NSURL *url = [NSURL URLWithString:URLString];
    
    //    NSString *fileAbsulotePath = [self.epubFile stringByAppendingString:[NSString stringWithFormat:@"/%@",fileName]];
    
    
    // 2.创建request请求
    NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url];
    
    __weak typeof(self) weakSelf = self;
    _dataTask = [self.manager dataTaskWithRequest:request completionHandler:^(NSURLResponse * _Nonnull response, id  _Nullable responseObject, NSError * _Nullable error) {
        //            NSLog(@"dataTaskWithRequest");
        //        NSLog(@"error -- %@",error);
        if (error == nil) {
            // MARK: 下载成功
            if (success) {
                success(fileName);
            }
        }else{
            // MARK: 下载失败
            if (failure) {
                failure(error);
            }
        }
        
        // 清空长度
        weakSelf.currentLength = 0;
        weakSelf.fileLength = 0;
        
        // 关闭fileHandle
        [weakSelf.fileHandle closeFile];
        weakSelf.fileHandle = nil;
        
    }];
    
    [self.manager setDataTaskDidReceiveResponseBlock:^NSURLSessionResponseDisposition(NSURLSession * _Nonnull session, NSURLSessionDataTask * _Nonnull dataTask, NSURLResponse * _Nonnull response) {
        //            NSLog(@"NSURLSessionResponseDisposition");
        
        // 获得下载文件的总长度：请求下载的文件长度 + 当前已经下载的文件长度
        weakSelf.fileLength = response.expectedContentLength + self.currentLength;
        
        //            NSLog(@"File downloaded to: %@",path);
        
        // MARK: 将下载的文件存储到本地
        // 创建一个空的文件到沙盒中
        NSFileManager *manager = [NSFileManager defaultManager];
        // 直接覆盖本地文件，省去删除
        [manager createFileAtPath:fileName contents:nil attributes:nil];
        
        //                // 如果没有下载文件的话，就创建一个文件。如果有下载文件的话，则不用重新创建(不然会覆盖掉之前的文件)
        //            if (![manager fileExistsAtPath:weakSelf.localURL]) {
        //                [manager createFileAtPath:weakSelf.localURL contents:nil attributes:nil];
        //            }
        
        // 创建文件句柄
        weakSelf.fileHandle = [NSFileHandle fileHandleForWritingAtPath:fileName];
        
        // 允许处理服务器的响应，才会继续接收服务器返回的数据
        return NSURLSessionResponseAllow;
    }];
    
    [self.manager setDataTaskDidReceiveDataBlock:^(NSURLSession * _Nonnull session, NSURLSessionDataTask * _Nonnull dataTask, NSData * _Nonnull data) {
        //            NSLog(@"setDataTaskDidReceiveDataBlock");
        
        // 指定数据的写入位置 -- 文件内容的最后面
        [weakSelf.fileHandle seekToEndOfFile];
        
        // 向沙盒写入数据
        [weakSelf.fileHandle writeData:data];
        
        // 拼接文件总长度
        weakSelf.currentLength += data.length;
        
        // 获取主线程，不然无法正确显示进度。
        NSOperationQueue* mainQueue = [NSOperationQueue mainQueue];
        [mainQueue addOperationWithBlock:^{
            // TODO: 下载进度
            if (weakSelf.fileLength == 0) {
                //                    weakSelf.progressView.progress = 0.0;
                //                    weakSelf.progressLabel.text = [NSString stringWithFormat:@"当前下载进度:00.00%%"];
                if (progress) {
                    progress(0.0,0,0);
                }
            } else {
                //                    weakSelf.progressView.progress =  1.0 * weakSelf.currentLength / weakSelf.fileLength;
                //                    weakSelf.progressLabel.text = [NSString stringWithFormat:@"当前下载进度:%.2f%%",100.0 * weakSelf.currentLength / weakSelf.fileLength];
                CGFloat progressNum = 100.0 * weakSelf.currentLength / weakSelf.fileLength;
                if (progress) {
                    progress(progressNum,weakSelf.fileLength,weakSelf.currentLength);
                }
            }
            
        }];
    }];
    
    [_dataTask resume];
    
}

- (AFURLSessionManager *)manager {
    if (!_manager) {
        NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration defaultSessionConfiguration];
        // 1. 创建会话管理者
        _manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:configuration];
        
        // 设置请求可接受类型 application/x-gzip
        AFJSONResponseSerializer *ser = [AFJSONResponseSerializer serializer];
        ser.acceptableContentTypes = [NSSet setWithObjects:@"application/x-gzip",@"application/epub+zip",@"application/octet-stream",@"application/zip",nil];
        _manager.responseSerializer = ser;
        
    }
    return _manager;
}

+ (NSString *)localURLWithBookId:(NSInteger)bookId try:(BOOL)try format:(NSInteger)format{
    if (format < 3) {
        
    }
    return [[self sharedInstance] localURLWithBookId:bookId try:try format:format];
}
- (NSString *)localURLWithBookId:(NSInteger)bookId try:(BOOL)try format:(NSInteger)format{
    NSString *floderPath = [self floderPathWithFormat:format];
    NSString *bidString = [NSString stringWithFormat:@"%ld",bookId];
    NSString *formatStr = stringWithFormat(format);
    NSString *endStr = stringWithTry(try);
    
    NSString *localFilePath = [NSString stringWithFormat:@"%@/%@_%@_%@.%@",
                               floderPath,
                               bidString,
                               endStr,
                               formatStr,
                               formatStr];
    return localFilePath;
    // 备注: 超媒体,单独处理
}

// MARK: epub路径
- (NSString *)epubFile{
    if (_epubFile == nil) {
        _epubFile = [self absulotePathWithOppositePath:@"epubFile"];
    }
    return _epubFile;
}
// MARK: pdf路径
- (NSString *)pdfFile{
    if (_pdfFile == nil) {
        _pdfFile = [self absulotePathWithOppositePath:@"pdfFile"];
    }
    return _pdfFile;
}
// MARK: 超媒体 zip 路径
- (NSString *)hyperZipFile{
    if (_hyperZipFile == nil) {
        _hyperZipFile = [self absulotePathWithOppositePath:@"hyperZipFile"];
    }
    return _hyperZipFile;
}
// MARK: 超媒体文件 解压后的路径
- (NSString *)hyperUnzipFile{
    if (_hyperUnzipFile == nil) {
        _hyperUnzipFile = [self absulotePathWithOppositePath:@"hyperUnzipFile"];
    }
    return _hyperUnzipFile;
}

// MARK: 初始化
// 初始化文件夹路径
+ (void)initLocalFilePath{
    [[self sharedInstance] initLocalFilePath];
}
- (void)initLocalFilePath{
    /// 初始化epub路径
    [self commenInitPathWithPath:self.epubFile];
    /// 初始化pdf路径
    [self commenInitPathWithPath:self.pdfFile];
    /// 初始化超媒体 压缩包路径
    [self commenInitPathWithPath:self.hyperZipFile];
    /// 初始化超媒体 解压缩路径
    [self commenInitPathWithPath:self.hyperUnzipFile];
}
- (instancetype)init{
    if (self = [super init]) {
        self.fileMgr = [NSFileManager defaultManager];
    }
    return self;
}
+ (instancetype)sharedInstance{
    static id instance;
    static dispatch_once_t once;
    dispatch_once(&once, ^{
        instance = [self new];
    });
    return instance;
}

// MARK: 私有通用方法
- (void)commenInitPathWithPath:(NSString *)path{
    BOOL isExist = [self.fileMgr fileExistsAtPath:path];
    if (isExist) {
    }else{
        NSError *error;
        BOOL createPath = [self.fileMgr createDirectoryAtPath:path withIntermediateDirectories:YES attributes:nil error:&error];
        if (createPath) {
            NSLog(@"创建路径成功 -- %@",path);
        }else{
            NSLog(@"创建路径失败 -- %@",error);
        }
    }
}
- (NSString *)absulotePathWithOppositePath:(NSString *)oppsitePath{
    return [[NSHomeDirectory() stringByAppendingPathComponent:@"Documents"] stringByAppendingPathComponent:oppsitePath];
}

- (NSString *)floderPathWithFormat:(NSInteger)format{
    switch (format) {
        case 1:{
            return self.pdfFile;
        }
            break;
        case 2:{
            return self.epubFile;
        }
            break;
//        case 3:{
//            return @"hyper_zip";
//        }
//            break;
        default:
            return @"";
            break;
    }
}

NSString *stringWithTry(BOOL try){
    if (try) {
        return @"test";
    }else{
        return @"offi";/// official
    }
}
NSString *stringWithFormat(NSInteger format){
    switch (format) {
        case 1:{
            return @"pdf";
        }
            break;
        case 2:{
            return @"epub";
        }
            break;
//        case 3:{
//            return @"hyper_zip";
//        }
//            break;
        default:
            return @"";
            break;
    }
}


@end




// -------------无法获取下载进度 progress
//    // 0.获取下载链接
//    NSURL *downloadURL = [NSURL URLWithString:URLString];
//
//    // 1.创建下载请求
//    NSURLRequest *request = [NSURLRequest requestWithURL:downloadURL];
//
//    // 2.创建下载请求配置对象
//    NSURLSessionConfiguration *config = [NSURLSessionConfiguration defaultSessionConfiguration];
//
//    // 3.创建session mgr
//    AFURLSessionManager *sessionMgr = [[AFURLSessionManager alloc] initWithSessionConfiguration:config];
//
//    // 4.创建下载任务
//    NSURLSessionDownloadTask *downloadTask = [sessionMgr downloadTaskWithRequest:request progress:^(NSProgress * _Nonnull downloadProgress) {
//        // TODO: 该回调不执行
//        if (progress) {
//            progress(1.0 * downloadProgress.completedUnitCount / downloadProgress.totalUnitCount,1.0 * downloadProgress.totalUnitCount,1.0 * downloadProgress.completedUnitCount);
//        }
//
//    } destination:^NSURL * _Nonnull(NSURL * _Nonnull targetPath, NSURLResponse * _Nonnull response) {
//        // 6.回调存储路径
//
//        NSString *localFileName = [NSString stringWithFormat:@"%@_%@",fileName,[response suggestedFilename]];
//
//        NSString *fileAbsulotePath = [self.epubFile stringByAppendingString:[NSString stringWithFormat:@"/%@",localFileName]];
//
//        NSURL *downloadURL = [NSURL fileURLWithPath:fileAbsulotePath];
//
//        //        NSLog(@"downloadURLPath -- %@",downloadURL.absoluteString);
//        if (success) {
//            success(downloadURL.absoluteString);
//        }
//
//        return downloadURL;
//    } completionHandler:^(NSURLResponse * _Nonnull response, NSURL * _Nullable filePath, NSError * _Nullable error) {
//        //如果下载的是压缩包的话，可以在这里进行解压
//        NSLog(@"filePath -- %@",filePath);
//
//        if (error == nil) {
//
//        }else{
//            NSLog(@"----%@---%ld---%@",error.domain,error.code,error);
//            //下载失败的时候，只列举判断了两种错误状态码
//            NSString * message = nil;
//            if (error.code == - 1005) {
//                message = @"网络异常";
//            }else if (error.code == -1001){
//                message = @"请求超时";
//            }else{
//                message = @"未知错误";
//            }
//            if (failure) {
//                failure(message);
//            }
//        }
//    }];
//
//    [downloadTask resume];
//
//    _downloadTask = downloadTask;
