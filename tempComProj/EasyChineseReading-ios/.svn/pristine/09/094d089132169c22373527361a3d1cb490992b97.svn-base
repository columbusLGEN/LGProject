/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _registerHooks = __webpack_require__(1);

	Object.keys(_registerHooks).forEach(function (key) {
	  if (key === "default") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function get() {
	      return _registerHooks[key];
	    }
	  });
	});

	var _smartimages = __webpack_require__(34);

	Object.keys(_smartimages).forEach(function (key) {
	  if (key === "default") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function get() {
	      return _smartimages[key];
	    }
	  });
	});

	var _smartmedias = __webpack_require__(35);

	Object.keys(_smartmedias).forEach(function (key) {
	  if (key === "default") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function get() {
	      return _smartmedias[key];
	    }
	  });
	});

	var _interface = __webpack_require__(36);

	var EpubReader = _interopRequireWildcard(_interface);

	var _Interface = __webpack_require__(40);

	var _GLPopMenu = __webpack_require__(3);

	var _GLBubbleView = __webpack_require__(26);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	var EPUBJS = EPUBJS || {};
	EPUBJS.VERSION = "1.00";
	window.EPUBJS = EPUBJS;

	window.initReader = EpubReader.initReader;
	window.gotoHref = EpubReader.gotoHref;
	window.gotoPage = EpubReader.gotoPage;
	window.gotoNote = EpubReader.gotoNote;
	window.gotoOffset = EpubReader.gotoOffset;
	window.gotoSearchText = EpubReader.gotoSearchText;
	window.getCurrentPos = EpubReader.getCurrentPos;
	window.resetFontSize = EpubReader.resetFontSize;
	window.resetFontFamily = EpubReader.resetFontFamily;
	window.searchText = EpubReader.searchText;
	window.setNightMode = EpubReader.setNightMode;
	window.addCss = EpubReader.addCss;
	window.removeCss = EpubReader.removeCss;
	window.configPageFlip = EpubReader.configPageFlip;

	//import { BubbleView } from './components/BubbleView.js';

	window.GLPopMenu = _GLPopMenu.GLPopMenu;
	window.GLBubbleView = _GLBubbleView.GLBubbleView;
	window.GLBubbleView.sharedInstance;
	//window.BubbleView = BubbleView;
	//window.BubbleView.sharedInstance;

	//
	window.EPUBJS.BookInterface = {};
	window.EPUBJS.BookInterface.textCopied = _Interface.textCopied;
	window.EPUBJS.BookInterface.getText = _Interface.getText;
	window.EPUBJS.BookInterface.createNote = _Interface.createNote;
	window.EPUBJS.BookInterface.repaintNote = _Interface.repaintNote;
	window.EPUBJS.BookInterface.updateNote = _Interface.updateNote;
	EPUBJS.BookInterface.configBackgroundColor = _Interface.configBackgroundColor;

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _NoteManager = __webpack_require__(2);

	var _Hooks = __webpack_require__(33);

	/**
	 *EPUBJS每次加载新的html时会调用
	 */
	_Hooks.Hooks.instance.registerHook(_Hooks.HooksKey.BEFORE_DISPLAY, function (args) {
	    var renderer = args[0];
	    _NoteManager.NoteManager.sharedInstance.view = renderer;
	    _NoteManager.NoteManager.sharedInstance.document = renderer.iframeObj.document;
	});

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.NoteManager = undefined;

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	//import { BubbleView } from '../components/BubbleView.js';


	var _GLPopMenu = __webpack_require__(3);

	var _GLBubbleView = __webpack_require__(26);

	var _Calculator = __webpack_require__(27);

	var _NoteList = __webpack_require__(30);

	var _Core = __webpack_require__(31);

	var _DomUtil = __webpack_require__(32);

	var _Utils = __webpack_require__(29);

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var _Symbol = __webpack_require__(8);
	var singleton = _Symbol();
	var singletonEnforcer = _Symbol();

	var NoteManager = exports.NoteManager = function () {
	    function NoteManager(enforcer) {
	        _classCallCheck(this, NoteManager);

	        if (enforcer !== singletonEnforcer) {
	            throw 'Need use NoteManager.sharedInstance to access.';
	        } else {
	            this.view = null;
	            this.document = null;
	            this.currentRangeClone = null;
	            this.height = 40;
	            //当前操作的group
	            this.currentGroupID = null;
	            this.noteList = new _NoteList.NoteList();
	            this.configPopMenu();
	        }
	    }

	    _createClass(NoteManager, [{
	        key: 'configPopMenu',
	        value: function configPopMenu() {
	            this.popMenu = _GLPopMenu.GLPopMenu.instance;
	            this.popMenu.setMenuItems([{
	                'text': '编辑',
	                'callback': this.editANote.bind(this)
	            }, {
	                'text': '删除',
	                'callback': this.deleteANote.bind(this)
	            }]);
	        }
	    }, {
	        key: 'setSelectionRange',
	        value: function setSelectionRange(range_) {
	            this.range = range_;
	        }
	    }, {
	        key: 'getSelectionRange',
	        value: function getSelectionRange() {
	            return this.range;
	        }

	        //删除一条笔记

	    }, {
	        key: 'deleteANote',
	        value: function deleteANote() {
	            this.clearInlineStyle(this.currentGroupID);
	            this.noteList.delete(this.currentGroupID);
	            _Core.Core.postMessageToMobile('deleteNote', this.currentGroupID);
	        }

	        //编辑一条笔记

	    }, {
	        key: 'editANote',
	        value: function editANote() {
	            _Core.Core.postMessageToMobile('editNote', NoteManager.sharedInstance.currentGroupID);
	        }

	        //更新页面上的笔记

	    }, {
	        key: 'updateNote',
	        value: function updateNote(groupId, comment) {
	            var treeWalker = this.document.createTreeWalker(this.document.body, NodeFilter.SHOW_ELEMENT, {
	                acceptNode: function acceptNode(node) {
	                    if (node.tagName.toLowerCase().trim() === 'div' && node.groupId == groupId) {
	                        return NodeFilter.FILTER_ACCEPT;
	                    } else {
	                        return NodeFilter.FILTER_SKIP;
	                    }
	                }
	            }, false);
	            while (treeWalker.nextNode()) {
	                node = treeWalker.currentNode;
	                node.data = comment;
	            }
	        }
	        /**
	         * 清除笔记
	         @param 此条笔记的uuid(dataId)
	         */

	    }, {
	        key: 'clearInlineStyle',
	        value: function clearInlineStyle(groupId) {
	            var treeWalker = this.document.createTreeWalker(this.document.body, NodeFilter.SHOW_ELEMENT, {
	                acceptNode: function acceptNode(node) {
	                    if (node.tagName.toLowerCase().trim() === 'div' && node.groupId == groupId) {
	                        return NodeFilter.FILTER_ACCEPT;
	                    } else {
	                        return NodeFilter.FILTER_SKIP;
	                    }
	                }
	            }, false);
	            var divs = [];
	            while (treeWalker.nextNode()) {
	                var _node = treeWalker.currentNode;
	                divs.push(_node);
	            }
	            for (var i = 0; i < divs.length; i++) {
	                var div = divs[i];
	                div.parentElement.removeChild(div);
	            }
	        }

	        /**
	         * 划线
	         @param text 选中的纯文本
	         @param comment 选中文本的笔记信息 可为null
	         @param startContainer 起始节点 / Range.startContainer
	         @param endContainer 终止节点 / Range.endContainer
	         @param startOffset 起始节点中的偏移量 Range.startOffset
	         @param endOffset 终止节点中的偏移量 Range.endOffset
	         @param parent 起始节点与终止节点的共同直接父元素 Range.commonAncestorContainer
	         @param needStore 当前划线信息是否需要存储 重绘的线不需要 新增的笔记需要存储 true 存储｜false 不存储
	         */

	    }, {
	        key: '_applyInlineStyle',
	        value: function _applyInlineStyle(note, needStore) {
	            //获取所有的textNode
	            var textNodes = _DomUtil.DomUtil.getAllTextNode(note.parent);
	            //找到所有选中文字的坐标信息
	            var coordinate = _DomUtil.DomUtil.getCoordinate(this.document, note.startContainer, note.endContainer, note.startOffset, note.endOffset, textNodes);
	            //解析坐标信息(几行？每行的宽度 和高度？及其显示位置？)
	            var divDatas = (0, _Calculator.getDivData)(coordinate);
	            // 根据解析来的坐标信息创建出div信息
	            var divs = (0, _Calculator.resolveDivData)(divDatas, note.groupId);
	            // 创建小圆点 如果 comment为null or "" icon为null
	            var icon = (0, _Calculator.resolveCommentIcon)(divDatas[divDatas.length - 1], note.comment, note.groupId);
	            for (var i = 0; i < divs.length; i++) {
	                this.document.body.appendChild(divs[i]);
	            }
	            if (icon) this.document.body.appendChild(icon);
	            // 将数据回传外层
	            if (needStore) {
	                var json = note.getJSON();
	                _Core.Core.postMessageToMobile('createNote', json);
	            }
	        }
	    }], [{
	        key: 'sharedInstance',
	        get: function get() {
	            if (!this[singleton]) {
	                this[singleton] = new NoteManager(singletonEnforcer);
	            }
	            return this[singleton];
	        }
	    }]);

	    return NoteManager;
	}();

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.GLPopMenu = undefined;

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _GLSVG = __webpack_require__(4);

	var _GLAnimation2 = __webpack_require__(6);

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 *类 iOS 文本 Selection 菜单
	 *
	 *当 position.y < frame 的高度时，尖角自动朝上
	 *当 position.y > frame 的高度时，尖角自动朝下
	 *当 (screen.width - position.x) < frame.width/2 || position.x < frame.width/2 *时，保持尖角在屏幕的相对位置不变，整体位置向左|右移，保证bounds落在屏幕内
	 */
	var _Symbol = __webpack_require__(8);
	var singleton = _Symbol();
	var singletonEnforcer = _Symbol();

	var GLPopMenu = exports.GLPopMenu = function (_GLAnimation) {
	    _inherits(GLPopMenu, _GLAnimation);

	    function GLPopMenu(enforcer) {
	        _classCallCheck(this, GLPopMenu);

	        if (enforcer !== singletonEnforcer) {
	            throw '大兄弟，俺是个单例类啊';
	        } else {
	            var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(GLPopMenu).call(this));

	            _this.width = 0;
	            _this.tapRanges = [];
	            /**
	             *鼠标经过的按钮区域索引
	             *实际上是没有按钮结点的，通过鼠标坐标位置确定当前落在哪个虚拟按钮区域
	             */
	            _this.movedIndex = 0;

	            _this.currentScale = _this.currentAlpha = 0;
	            _this.currentTranslate = 30;

	            _this.isShow = false;
	            _this.panel = _this.createPanel();
	            _this.panelTapHandler = function (e) {
	                _this.panelTapped(e);
	            };
	            _this.menuTapHandler = function (e) {
	                _this.menuTapped(e);
	            };
	            // this.animationNode = this.group;
	            _this.svg = new _GLSVG.GLSVG();
	            _this.panel.appendChild(_this.svg.domElement);
	        }
	        return _possibleConstructorReturn(_this);
	    }

	    _createClass(GLPopMenu, [{
	        key: 'setMenuItems',


	        /**
	         *设置菜单项
	         *
	         *@param {Array} -> {text, callback}  items 菜单项及回调
	         */
	        value: function setMenuItems(items) {
	            this.parseItems(items);
	        }

	        /**
	         *显示或隐藏菜单
	         *
	         *@param {Array} point 显示在屏幕上的X,Y坐标
	         */

	    }, {
	        key: 'ifNeedsDisplay',
	        value: function ifNeedsDisplay(position) {
	            if (self.isAnimating) {
	                return;
	            }
	            if (this.isShow === true) {
	                this.quitDisplay();
	            } else {
	                document.body.appendChild(this.panel);
	                this.svg.setPosition(position);
	                this.dispaly();
	            }
	        }

	        //显示

	    }, {
	        key: 'dispaly',
	        value: function dispaly() {
	            this.isShow = true;
	            this.svg.domElement.style.opacity = this.currentAlpha = 0;
	            //this.panel.style.visibility = 'visible';
	            document.body.appendChild(this.panel);

	            this.startAnimating();
	        }

	        //退出显示

	    }, {
	        key: 'quitDisplay',
	        value: function quitDisplay() {
	            this.isShow = false;
	            this.startAnimating();
	        }
	    }, {
	        key: 'stopAnimating',
	        value: function stopAnimating() {
	            _get(Object.getPrototypeOf(GLPopMenu.prototype), 'stopAnimating', this).call(this);
	            if (this.isShow === false) {
	                this.removeTapListener(this.panel, this.panelTapHandler);
	                this.removeTapListener(this.svg.domElement, this.menuTapHandler);
	                //this.panel.style.visibility = 'hidden';
	                document.body.removeChild(this.panel);
	            } else {
	                this.addTapListener(this.panel, this.panelTapHandler);
	                this.addTapListener(this.svg.domElement, this.menuTapHandler);
	            }
	        }
	    }, {
	        key: 'enterFrame',
	        value: function enterFrame() {
	            if (this.isShow === true) {
	                this.currentAlpha += 0.07;
	            } else {
	                this.currentAlpha -= 0.11;
	            }
	            //边界条件检测
	            if (this.currentAlpha <= 0.05 || this.currentAlpha > 0.95) {
	                this.currentAlpha = this.isShow === true ? 1.0 : 0.0;
	                this.svg.domElement.style.opacity = this.currentAlpha;
	                this.stopAnimating();
	            } else {
	                this.svg.domElement.style.opacity = this.currentAlpha;
	                _get(Object.getPrototypeOf(GLPopMenu.prototype), 'enterFrame', this).call(this);
	            }
	        }
	    }, {
	        key: 'panelTapped',
	        value: function panelTapped(e) {
	            e.stopPropagation();
	            this.quitDisplay();
	        }
	    }, {
	        key: 'menuTapped',
	        value: function menuTapped(e) {
	            e.stopPropagation();
	            var touchX, touchY;
	            var tp = this.getTouchedPosition(e);
	            var rect = this.svg.frame;
	            touchX = tp.x - rect.x;
	            touchY = tp.y - rect.y;

	            for (var i = 0; i < this.tapRanges.length; i++) {
	                if (touchX < this.tapRanges[i].to) {
	                    this.tapRanges[i].callback();
	                    this.quitDisplay();
	                    break;
	                }
	            }
	        }
	    }, {
	        key: 'parseItems',
	        value: function parseItems(items) {
	            //按钮的点击范围
	            this.tapRanges = [];
	            var length = 0;
	            var padding = 10;
	            var rangeFrom = padding;
	            for (var i = 0; i < items.length; i++) {
	                var text = items[i].text;
	                var pixelLength = text.length * 16 + padding * 2;
	                var tempTo = rangeFrom + pixelLength;

	                this.tapRanges[i] = {
	                    text: text,
	                    from: rangeFrom,
	                    to: tempTo,
	                    center: rangeFrom + pixelLength / 2,
	                    callback: items[i].callback
	                };
	                length += text.length;
	                rangeFrom = tempTo;
	            }
	            var lastItem = this.tapRanges[items.length - 1];
	            lastItem.to = lastItem.to + padding;
	            this.width = lastItem.to;

	            this.svg.width = this.width;
	            this.svg.textItems = this.tapRanges;
	        }
	    }, {
	        key: 'createPanel',
	        value: function createPanel() {
	            var style = 'position:fixed; z-index:20000; top:0px; left:0px;  -webkit-tap-highlight-color:rgba(0, 0, 0, 0); -webkit-user-select: none; user-select: none; width:' + window.innerWidth + 'px; ' + 'height:' + window.innerHeight + 'px;';
	            var div = document.createElement('div');
	            div.setAttribute('style', style);
	            return div;
	        }
	    }], [{
	        key: 'instance',
	        get: function get() {
	            if (!this[singleton]) {
	                this[singleton] = new GLPopMenu(singletonEnforcer);
	            }
	            return this[singleton];
	        }
	    }]);

	    return GLPopMenu;
	}(_GLAnimation2.GLAnimation);

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var GREN = __webpack_require__(5);

	var GLSVG = exports.GLSVG = function () {
	    function GLSVG() {
	        _classCallCheck(this, GLSVG);

	        //是不是尖角朝上
	        this.isUpDirection = false;
	        this.minWidth = 64;
	        this.directionOffsetY = 0;

	        this.textItems = null;
	        this.frame = new GREN.GLRect(100, 100, 64, 48);

	        //左右最小边距
	        this.marginLeft = 5;
	        this.marginRight = 5;

	        this.screenWidth = window.innerWidth;
	        this.maxFrameX = this.screenWidth - this.marginRight;
	        this.angleOffsetX = 0;

	        this.domElement = this.createSVGElement();
	    }

	    _createClass(GLSVG, [{
	        key: 'setPosition',
	        value: function setPosition(position) {
	            this.frame.center = GREN.Vector2.copy(position);
	            var spaceHeight = this.frame.height + this.directionOffsetY;
	            if (position.y < spaceHeight) {
	                this.isUpDirection = true;
	                this.frame.y = position.y + this.directionOffsetY;
	            } else {
	                this.isUpDirection = false;
	                this.frame.y = position.y - spaceHeight;
	            }
	            //计算在 X 轴上 menu 的 frame（rect）在屏幕内
	            var angleOffsetX = 0;
	            if (this.frame.x < this.marginLeft) {
	                angleOffsetX = this.frame.x - this.marginLeft;
	                this.frame.x = this.marginLeft;
	            } else if (this.frame.getMaxX() > this.maxFrameX) {
	                angleOffsetX = this.frame.getMaxX() - this.maxFrameX;
	                this.frame.x = this.maxFrameX - this.frame.width;
	            }
	            //校验尖角的偏移量
	            this.angleOffsetX = this.validateAngleOffsetX(angleOffsetX);
	            this.domElement.style.top = this.frame.y + 'px';
	            this.domElement.style.left = this.frame.x + 'px';
	            this.attachText();
	            this.calculateBorder();
	        }

	        //校验尖角的偏移量

	    }, {
	        key: 'validateAngleOffsetX',
	        value: function validateAngleOffsetX(angleOffsetX) {
	            var maxOffsetX = this.frame.halfWidth - 13;
	            if (this.isUpDirection) {
	                angleOffsetX *= -1;
	            }
	            if (angleOffsetX < -maxOffsetX) {
	                angleOffsetX = -maxOffsetX;
	            } else if (angleOffsetX > maxOffsetX) {
	                angleOffsetX = maxOffsetX;
	            }
	            return angleOffsetX;
	        }
	    }, {
	        key: 'attachText',
	        value: function attachText() {
	            var textOffsetY = 21;

	            if (this.isUpDirection) {
	                textOffsetY = 21 + 16;
	                this.backgroundGroup.setAttribute('transform', 'translate(' + this.frame.halfWidth + ', ' + this.frame.halfHeight + ') rotate(180) translate(' + this.frame.halfWidth * -1 + ', ' + this.frame.halfHeight * -1 + ')');
	            } else {
	                this.backgroundGroup.setAttribute('transform', 'rotate(0)');
	            }
	            var textNodes = this.textGroup.querySelectorAll('text');
	            for (var i = 0; i < this.textItems.length; i++) {
	                var node = textNodes[i];
	                node.setAttribute('x', this.textItems[i].center);
	                node.setAttribute('y', textOffsetY);
	                node.textContent = this.textItems[i].text;
	            }
	        }
	    }, {
	        key: 'calculateBorder',
	        value: function calculateBorder() {
	            var radius = 3;
	            var trangleHeight = 6;
	            var trangleWidth = 10;
	            var minX = 0.5,
	                maxX = this.frame.width - 1,
	                minY = 0.5,
	                maxY = 32;
	            var angleCenterX = maxX / 2 + this.angleOffsetX;
	            var borderPath = 'M' + (minX + radius) + ' ' + minY + ' L' + (maxX - radius) + ' ' + minY + ' A' + radius + ' ' + radius + ' 0 0 1 ' + maxX + ' ' + (minY + radius) + ' L' + maxX + ' ' + (maxY - radius) + ' A' + radius + ' ' + radius + ' 0 0 1 ' + (maxX - radius) + ' ' + maxY +
	            //尖角
	            // ' Q'+(midX)+' '+(maxY+trangleHeight/2)+' '+midX+' '+(maxY+trangleHeight);
	            // ' A'+radius+' '+radius+' 0 0 1 '+midX+' '+(maxY+trangleHeight);
	            ' L' + (angleCenterX + trangleWidth / 2) + ' ' + maxY + ' L' + angleCenterX + ' ' + (maxY + trangleHeight) + ' L' + (angleCenterX - trangleWidth / 2) + ' ' + maxY + ' L' + (minX + radius) + ' ' + maxY + ' A' + radius + ' ' + radius + ' 0 0 1 ' + minX + ' ' + (maxY - radius) + ' L' + minX + ' ' + (minY + radius) + ' A' + radius + ' ' + radius + ' 0 0 1 ' + (minX + radius) + ' ' + minY;

	            this.borderPath.setAttribute('d', borderPath);
	        }
	    }, {
	        key: 'createSVGElement',
	        value: function createSVGElement() {
	            var svgNS = 'http://www.w3.org/2000/svg';
	            var xlinkNS = 'http://www.w3.org/1999/xlink';

	            function createElement(name) {
	                return document.createElementNS(svgNS, name);
	            }

	            function setPosition(element, px, py) {
	                element.setAttributeNS(null, 'x', px);
	                element.setAttributeNS(null, 'y', py);
	            }

	            function setStyle(element, style) {
	                element.setAttributeNS(null, 'style', style);
	            }

	            function setCommonAttri(element, id, width, height) {
	                element.setAttributeNS(null, 'id', id);
	                element.setAttributeNS(null, 'width', width);
	                element.setAttributeNS(null, 'height', height);
	            }

	            function createUse(px, py, style) {
	                var use = createElement('use');
	                setPosition(use, px, py);
	                setStyle(use, style);
	                use.setAttributeNS(xlinkNS, 'href', '#border');
	                return use;
	            }

	            var noSelect = '-webkit-touch-callout: none; -webkit-user-select: none;-khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none;-webkit-tap-highlight-color: rgba(255, 255, 255, 0);';

	            var svg = createElement('svg');
	            setCommonAttri(svg, 'glpopmenu', this.minWidth, this.frame.height);
	            setStyle(svg, 'cursor:hand; position: absolute; visibility:visiable;' + noSelect);

	            var symbol = createElement('symbol');
	            symbol.setAttributeNS(null, 'id', 'border');

	            this.borderPath = document.createElementNS(svgNS, 'path');
	            symbol.appendChild(this.borderPath);
	            svg.appendChild(symbol);

	            var defs = createElement('defs');
	            var mask = createElement('mask');
	            setCommonAttri(mask, 'alphaMask', '400', '48');

	            var rect = createElement('rect');
	            setCommonAttri(rect, 'rect', '400', '48');
	            setStyle(rect, 'stroke:none; fill: #333333;' + noSelect);
	            mask.appendChild(rect);
	            defs.appendChild(mask);
	            svg.appendChild(defs);

	            //阴影
	            var use0 = createUse('0', '2', 'fill:#000000;stroke-width:0; mask:url(#alphaMask);');
	            var use1 = createUse('0', '0', 'fill:#555;stroke:#353535;stroke-width:1;');

	            this.backgroundGroup = createElement('g');
	            this.backgroundGroup.appendChild(use0);
	            this.backgroundGroup.appendChild(use1);
	            svg.appendChild(this.backgroundGroup);

	            //文本节点,默认创建 6 个
	            this.textGroup = createElement('g');
	            setStyle(this.textGroup, 'font-size:16px;fill:#eeeeee;text-anchor: middle');
	            for (var i = 0; i < 6; i++) {
	                var text = createElement('text');
	                text.setAttributeNS(null, 'x', '0');
	                text.setAttributeNS(null, 'y', '21');
	                this.textGroup.appendChild(text);
	            }
	            svg.appendChild(this.textGroup);
	            return svg;
	        }
	    }, {
	        key: 'width',
	        set: function set(value) {
	            this.frame.width = value < this.minWidth ? this.minWidth : value;
	            this.domElement.setAttribute('width', value);
	        }
	    }]);

	    return GLSVG;
	}();

/***/ },
/* 5 */
/***/ function(module, exports) {

	module.exports = GREN;

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.GLAnimation = undefined;

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _config = __webpack_require__(7);

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Created by grenlight on 16/7/18.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

	/*这样判断是否为tap事件:
	  * 计算move的距离,如果小于6,则为点击
	  */


	var touchStartPoint = null;
	var touchDistance = 0;
	var minTouchDistance = 6;
	var eventElement = null;

	var GREN = __webpack_require__(5);

	var GLAnimation = exports.GLAnimation = function (_GREN$IAnimation) {
	    _inherits(GLAnimation, _GREN$IAnimation);

	    function GLAnimation() {
	        _classCallCheck(this, GLAnimation);

	        return _possibleConstructorReturn(this, Object.getPrototypeOf(GLAnimation).apply(this, arguments));
	    }

	    _createClass(GLAnimation, [{
	        key: 'addTapListener',
	        value: function addTapListener(element, handler) {
	            eventElement = element;

	            element.addEventListener(_config.TOUCH_START, this.touchStartHandler.bind(this), false);
	            element.addEventListener(_config.TOUCH_END, handler, false);
	        }
	    }, {
	        key: 'removeTapListener',
	        value: function removeTapListener(element, handler) {
	            element.removeEventListener(_config.TOUCH_START, this.touchStartHandler.bind(this), false);
	            element.removeEventListener(_config.TOUCH_END, handler, false);
	        }
	    }, {
	        key: 'touchStartHandler',
	        value: function touchStartHandler(e) {
	            e.stopPropagation();
	            touchStartPoint = this.getTouchedPosition(e);
	            touchDistance = null;
	        }
	    }, {
	        key: 'isTapEvent',
	        value: function isTapEvent() {
	            var e = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];

	            if (e !== null) {
	                var movePoint = this.getTouchedPosition(e);
	                touchDistance = new GREN.Vector2(Math.abs(movePoint.x - touchStartPoint.x), Math.abs(movePoint.y - touchStartPoint.y));
	            }
	            if (touchDistance === null || touchDistance.x < minTouchDistance && touchDistance.y < minTouchDistance) {
	                return true;
	            }
	            return false;
	        }
	    }, {
	        key: 'getTouchedPosition',
	        value: function getTouchedPosition(e) {
	            if (e.pageX) {
	                return new GREN.Vector2(e.pageX, e.pageY);
	            } else {
	                return new GREN.Vector2(e.changedTouches[0].pageX, e.changedTouches[0].pageY);
	            }
	        }
	    }]);

	    return GLAnimation;
	}(GREN.IAnimation);

/***/ },
/* 7 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	/**
	 * Created by grenlight on 16/2/1.
	 */

	/**
	 * 阅读器版本
	 *
	 * 1. JS的影响排版的更新加上版本号
	 * 2. App端记录排版结果时，也记录上JS版本号
	 * 3. JS在拿到App端传来的缓存排版数据后对比版本号，如果不匹配，则抛弃传来的缓存数据重新计算。
	 *
	 * @type {string}
	 */
	var vertion = exports.vertion = '1.2';

	var TOUCH_START = exports.TOUCH_START = 'mousedown';
	var TOUCH_MOVE = exports.TOUCH_MOVE = 'mousemove';
	var TOUCH_END = exports.TOUCH_END = 'mouseup';
	var TOUCH_CANCEL = exports.TOUCH_CANCEL = 'mouseout';

	if (/Android|iPhone|iPad|iPod|BlackBerry|BB|PlayBook|IEMobile|Windows Phone|Kindle/i.test(navigator.userAgent)) {
	  exports.TOUCH_START = TOUCH_START = 'touchstart';
	  exports.TOUCH_END = TOUCH_END = 'touchend';
	  exports.TOUCH_MOVE = TOUCH_MOVE = 'touchmove';
	  exports.TOUCH_CANCEL = TOUCH_CANCEL = 'touchcancel';
	}

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	module.exports = __webpack_require__(9)() ? Symbol : __webpack_require__(10);


/***/ },
/* 9 */
/***/ function(module, exports) {

	'use strict';

	module.exports = function () {
		var symbol;
		if (typeof Symbol !== 'function') return false;
		symbol = Symbol('test symbol');
		try { String(symbol); } catch (e) { return false; }
		if (typeof Symbol.iterator === 'symbol') return true;

		// Return 'true' for polyfills
		if (typeof Symbol.isConcatSpreadable !== 'object') return false;
		if (typeof Symbol.iterator !== 'object') return false;
		if (typeof Symbol.toPrimitive !== 'object') return false;
		if (typeof Symbol.toStringTag !== 'object') return false;
		if (typeof Symbol.unscopables !== 'object') return false;

		return true;
	};


/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	// ES2015 Symbol polyfill for environments that do not support it (or partially support it_

	'use strict';

	var d              = __webpack_require__(11)
	  , validateSymbol = __webpack_require__(24)

	  , create = Object.create, defineProperties = Object.defineProperties
	  , defineProperty = Object.defineProperty, objPrototype = Object.prototype
	  , NativeSymbol, SymbolPolyfill, HiddenSymbol, globalSymbols = create(null);

	if (typeof Symbol === 'function') NativeSymbol = Symbol;

	var generateName = (function () {
		var created = create(null);
		return function (desc) {
			var postfix = 0, name, ie11BugWorkaround;
			while (created[desc + (postfix || '')]) ++postfix;
			desc += (postfix || '');
			created[desc] = true;
			name = '@@' + desc;
			defineProperty(objPrototype, name, d.gs(null, function (value) {
				// For IE11 issue see:
				// https://connect.microsoft.com/IE/feedbackdetail/view/1928508/
				//    ie11-broken-getters-on-dom-objects
				// https://github.com/medikoo/es6-symbol/issues/12
				if (ie11BugWorkaround) return;
				ie11BugWorkaround = true;
				defineProperty(this, name, d(value));
				ie11BugWorkaround = false;
			}));
			return name;
		};
	}());

	// Internal constructor (not one exposed) for creating Symbol instances.
	// This one is used to ensure that `someSymbol instanceof Symbol` always return false
	HiddenSymbol = function Symbol(description) {
		if (this instanceof HiddenSymbol) throw new TypeError('TypeError: Symbol is not a constructor');
		return SymbolPolyfill(description);
	};

	// Exposed `Symbol` constructor
	// (returns instances of HiddenSymbol)
	module.exports = SymbolPolyfill = function Symbol(description) {
		var symbol;
		if (this instanceof Symbol) throw new TypeError('TypeError: Symbol is not a constructor');
		symbol = create(HiddenSymbol.prototype);
		description = (description === undefined ? '' : String(description));
		return defineProperties(symbol, {
			__description__: d('', description),
			__name__: d('', generateName(description))
		});
	};
	defineProperties(SymbolPolyfill, {
		for: d(function (key) {
			if (globalSymbols[key]) return globalSymbols[key];
			return (globalSymbols[key] = SymbolPolyfill(String(key)));
		}),
		keyFor: d(function (s) {
			var key;
			validateSymbol(s);
			for (key in globalSymbols) if (globalSymbols[key] === s) return key;
		}),

		// If there's native implementation of given symbol, let's fallback to it
		// to ensure proper interoperability with other native functions e.g. Array.from
		hasInstance: d('', (NativeSymbol && NativeSymbol.hasInstance) || SymbolPolyfill('hasInstance')),
		isConcatSpreadable: d('', (NativeSymbol && NativeSymbol.isConcatSpreadable) ||
			SymbolPolyfill('isConcatSpreadable')),
		iterator: d('', (NativeSymbol && NativeSymbol.iterator) || SymbolPolyfill('iterator')),
		match: d('', (NativeSymbol && NativeSymbol.match) || SymbolPolyfill('match')),
		replace: d('', (NativeSymbol && NativeSymbol.replace) || SymbolPolyfill('replace')),
		search: d('', (NativeSymbol && NativeSymbol.search) || SymbolPolyfill('search')),
		species: d('', (NativeSymbol && NativeSymbol.species) || SymbolPolyfill('species')),
		split: d('', (NativeSymbol && NativeSymbol.split) || SymbolPolyfill('split')),
		toPrimitive: d('', (NativeSymbol && NativeSymbol.toPrimitive) || SymbolPolyfill('toPrimitive')),
		toStringTag: d('', (NativeSymbol && NativeSymbol.toStringTag) || SymbolPolyfill('toStringTag')),
		unscopables: d('', (NativeSymbol && NativeSymbol.unscopables) || SymbolPolyfill('unscopables'))
	});

	// Internal tweaks for real symbol producer
	defineProperties(HiddenSymbol.prototype, {
		constructor: d(SymbolPolyfill),
		toString: d('', function () { return this.__name__; })
	});

	// Proper implementation of methods exposed on Symbol.prototype
	// They won't be accessible on produced symbol instances as they derive from HiddenSymbol.prototype
	defineProperties(SymbolPolyfill.prototype, {
		toString: d(function () { return 'Symbol (' + validateSymbol(this).__description__ + ')'; }),
		valueOf: d(function () { return validateSymbol(this); })
	});
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toPrimitive, d('',
		function () { return validateSymbol(this); }));
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d('c', 'Symbol'));

	// Proper implementaton of toPrimitive and toStringTag for returned symbol instances
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toStringTag,
		d('c', SymbolPolyfill.prototype[SymbolPolyfill.toStringTag]));

	// Note: It's important to define `toPrimitive` as last one, as some implementations
	// implement `toPrimitive` natively without implementing `toStringTag` (or other specified symbols)
	// And that may invoke error in definition flow:
	// See: https://github.com/medikoo/es6-symbol/issues/13#issuecomment-164146149
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toPrimitive,
		d('c', SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive]));


/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var assign        = __webpack_require__(12)
	  , normalizeOpts = __webpack_require__(19)
	  , isCallable    = __webpack_require__(20)
	  , contains      = __webpack_require__(21)

	  , d;

	d = module.exports = function (dscr, value/*, options*/) {
		var c, e, w, options, desc;
		if ((arguments.length < 2) || (typeof dscr !== 'string')) {
			options = value;
			value = dscr;
			dscr = null;
		} else {
			options = arguments[2];
		}
		if (dscr == null) {
			c = w = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
			w = contains.call(dscr, 'w');
		}

		desc = { value: value, configurable: c, enumerable: e, writable: w };
		return !options ? desc : assign(normalizeOpts(options), desc);
	};

	d.gs = function (dscr, get, set/*, options*/) {
		var c, e, options, desc;
		if (typeof dscr !== 'string') {
			options = set;
			set = get;
			get = dscr;
			dscr = null;
		} else {
			options = arguments[3];
		}
		if (get == null) {
			get = undefined;
		} else if (!isCallable(get)) {
			options = get;
			get = set = undefined;
		} else if (set == null) {
			set = undefined;
		} else if (!isCallable(set)) {
			options = set;
			set = undefined;
		}
		if (dscr == null) {
			c = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
		}

		desc = { get: get, set: set, configurable: c, enumerable: e };
		return !options ? desc : assign(normalizeOpts(options), desc);
	};


/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	module.exports = __webpack_require__(13)()
		? Object.assign
		: __webpack_require__(14);


/***/ },
/* 13 */
/***/ function(module, exports) {

	'use strict';

	module.exports = function () {
		var assign = Object.assign, obj;
		if (typeof assign !== 'function') return false;
		obj = { foo: 'raz' };
		assign(obj, { bar: 'dwa' }, { trzy: 'trzy' });
		return (obj.foo + obj.bar + obj.trzy) === 'razdwatrzy';
	};


/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var keys  = __webpack_require__(15)
	  , value = __webpack_require__(18)

	  , max = Math.max;

	module.exports = function (dest, src/*, …srcn*/) {
		var error, i, l = max(arguments.length, 2), assign;
		dest = Object(value(dest));
		assign = function (key) {
			try { dest[key] = src[key]; } catch (e) {
				if (!error) error = e;
			}
		};
		for (i = 1; i < l; ++i) {
			src = arguments[i];
			keys(src).forEach(assign);
		}
		if (error !== undefined) throw error;
		return dest;
	};


/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	module.exports = __webpack_require__(16)()
		? Object.keys
		: __webpack_require__(17);


/***/ },
/* 16 */
/***/ function(module, exports) {

	'use strict';

	module.exports = function () {
		try {
			Object.keys('primitive');
			return true;
		} catch (e) { return false; }
	};


/***/ },
/* 17 */
/***/ function(module, exports) {

	'use strict';

	var keys = Object.keys;

	module.exports = function (object) {
		return keys(object == null ? object : Object(object));
	};


/***/ },
/* 18 */
/***/ function(module, exports) {

	'use strict';

	module.exports = function (value) {
		if (value == null) throw new TypeError("Cannot use null or undefined");
		return value;
	};


/***/ },
/* 19 */
/***/ function(module, exports) {

	'use strict';

	var forEach = Array.prototype.forEach, create = Object.create;

	var process = function (src, obj) {
		var key;
		for (key in src) obj[key] = src[key];
	};

	module.exports = function (options/*, …options*/) {
		var result = create(null);
		forEach.call(arguments, function (options) {
			if (options == null) return;
			process(Object(options), result);
		});
		return result;
	};


/***/ },
/* 20 */
/***/ function(module, exports) {

	// Deprecated

	'use strict';

	module.exports = function (obj) { return typeof obj === 'function'; };


/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	module.exports = __webpack_require__(22)()
		? String.prototype.contains
		: __webpack_require__(23);


/***/ },
/* 22 */
/***/ function(module, exports) {

	'use strict';

	var str = 'razdwatrzy';

	module.exports = function () {
		if (typeof str.contains !== 'function') return false;
		return ((str.contains('dwa') === true) && (str.contains('foo') === false));
	};


/***/ },
/* 23 */
/***/ function(module, exports) {

	'use strict';

	var indexOf = String.prototype.indexOf;

	module.exports = function (searchString/*, position*/) {
		return indexOf.call(this, searchString, arguments[1]) > -1;
	};


/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var isSymbol = __webpack_require__(25);

	module.exports = function (value) {
		if (!isSymbol(value)) throw new TypeError(value + " is not a symbol");
		return value;
	};


/***/ },
/* 25 */
/***/ function(module, exports) {

	'use strict';

	module.exports = function (x) {
		return (x && ((typeof x === 'symbol') || (x['@@toStringTag'] === 'Symbol'))) || false;
	};


/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.GLBubbleView = undefined;

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _GLAnimation2 = __webpack_require__(6);

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var GLEdgeInsets = function GLEdgeInsets() {
	    var top = arguments.length <= 0 || arguments[0] === undefined ? 0 : arguments[0];
	    var left = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];
	    var bottom = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];
	    var right = arguments.length <= 3 || arguments[3] === undefined ? 0 : arguments[3];

	    _classCallCheck(this, GLEdgeInsets);

	    this.top = top;
	    this.left = left;
	    this.bottom = bottom;
	    this.right = right;
	};
	/**
	 *汽泡视图：应用于展示图文消息
	 *
	 *特点：
	 *
	 *单例；
	 *自负视图显隐,减小外部调用时的逻辑判断；
	 *bubbleView 默认显示在点击区域的上方，上方的显示空间不够时显示在点击区域的下方
	 *显示时阻止 window 滚动及下层 html 的事件响应；
	 *点击 bubbleView 的其它区域时，bubbleView 消失；
	 *点击 bubbleView 上面时，消失并执行回调；
	 */


	var _Symbol = __webpack_require__(8);
	var singleton = _Symbol();
	var singletonEnforcer = _Symbol();

	var GLBubbleView = exports.GLBubbleView = function (_GLAnimation) {
	    _inherits(GLBubbleView, _GLAnimation);

	    function GLBubbleView(enforcer) {
	        _classCallCheck(this, GLBubbleView);

	        if (enforcer !== singletonEnforcer) {
	            throw 'GLBubbleView 是单例类，调用方法：GLBubbleView.sharedInstance';
	        } else {
	            var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(GLBubbleView).call(this));

	            _this.isShow = false;
	            //是不是尖角朝上
	            _this.isUpDirection = false;
	            _this.directionOffsetY = 9;
	            _this.cornerRadius = 6;
	            _this.frame = new GREN.GLRect(0, 0, 100, 60);
	            _this.angleFrame = new GREN.GLRect(0, 0, 10, 7);
	            //左右最小边距
	            _this.marginLeft = 5;
	            _this.marginRight = 5;
	            _this.maxFrameX = window.innerWidth - _this.marginRight;

	            _this.fontSize = 16;
	            _this.lineHeight = 18;
	            _this.maxTextLines = 4;
	            //文本内容相关
	            _this.content = null;
	            _this.contentSize = { width: 0, height: 0 };
	            _this.contentMargin = new GLEdgeInsets(12, 12, 10, 12);
	            _this.contentDiv = _this.createContentDiv();

	            _this.panel = _this.createPanel(window.innerWidth, window.innerHeight);
	            _this.panel.appendChild(_this.contentDiv);

	            _this.initCanvas();

	            _this.tappedHandler = function (e) {
	                _this.tapped(e);
	            };
	        }
	        return _possibleConstructorReturn(_this);
	    }

	    _createClass(GLBubbleView, [{
	        key: 'ifNeedsDisplay',


	        /**
	         *@param innerCallback {function}  点击发生在汽泡内时执行的回调
	         *@param outerCallback {function}  点击发生在汽泡外时执行的回调
	         */
	        value: function ifNeedsDisplay(text, position, innerCallback, outerCallback) {
	            if (this.isShow === true) {
	                this.hidden();
	            } else {
	                this.content = text;
	                this.anglePosition = position;
	                this.tappedInnerCallback = innerCallback;
	                this.tappedOuterCallback = outerCallback;
	                this.show();
	            }
	        }
	    }, {
	        key: 'show',
	        value: function show() {
	            this.isShow = true;
	            this.currentAlpha = 0;
	            var pixelLength = this.getTextPixelLength(this.content);
	            this.updateContent(pixelLength);
	            this.updateBubbleSize(this.anglePosition);
	            this.updateBubbleGraph();
	            this.startAnimating();

	            document.body.appendChild(this.panel);
	            this.addTapListener(this.panel, this.tappedHandler);
	        }
	    }, {
	        key: 'hidden',
	        value: function hidden() {
	            this.isShow = false;
	            this.removeTapListener(this.panel, this.tappedHandler);
	            document.body.removeChild(this.panel);
	            _get(Object.getPrototypeOf(GLBubbleView.prototype), 'stopAnimating', this).call(this);
	        }
	    }, {
	        key: 'stopAnimating',
	        value: function stopAnimating() {
	            _get(Object.getPrototypeOf(GLBubbleView.prototype), 'stopAnimating', this).call(this);
	            if (this.isShow === false) {} else {
	                // this.panel.appendChild(this.contentDiv);
	            }
	        }
	    }, {
	        key: 'enterFrame',
	        value: function enterFrame() {
	            this.isAnimating = true;
	            if (this.isShow === true) {
	                this.currentAlpha += 0.07;
	            } else {
	                this.currentAlpha -= 0.09;
	            }
	            this.contentDiv.opacity = this.currentAlpha;
	            this.stage.alpha = this.currentAlpha;
	            this.renderer.render(this.stage);
	            //边界条件检测
	            if (this.currentAlpha < 0.0 || this.currentAlpha >= 1.0) {
	                this.currentAlpha = this.currentAlpha < 0.0 ? 0 : 1;
	                this.stopAnimating();
	                //解决华为手机上最后一帧图层变透明的bug
	                this.stage.alpha = this.currentAlpha;
	                this.renderer.render(this.stage);
	            } else {
	                _get(Object.getPrototypeOf(GLBubbleView.prototype), 'enterFrame', this).call(this);
	            }
	        }
	    }, {
	        key: 'tapped',
	        value: function tapped(e) {
	            e.preventDefault();
	            if (this.isTapEvent(e) === false) {
	                return;
	            }
	            var tp = this.getTouchedPosition(e);
	            var point = new PIXI.Point(tp.x - window.pageXOffset, tp.y - window.pageYOffset);
	            if (this.graphics.containsPoint(point)) {
	                if (typeof this.tappedInnerCallback === 'function') {
	                    this.tappedInnerCallback();
	                }
	            } else {
	                if (typeof this.tappedOuterCallback === 'function') {
	                    this.tappedOuterCallback();
	                }
	            }
	            this.hidden();
	        }
	    }, {
	        key: 'updateContent',
	        value: function updateContent(pixelLength) {
	            if (pixelLength <= 100) {
	                this.contentSize.width = pixelLength;
	                this.contentSize.height = this.lineHeight;
	            } else {
	                var v = Math.ceil(pixelLength / 100);
	                if (v < this.maxTextLines) {
	                    this.contentSize.width = 100;
	                    this.contentSize.height = this.lineHeight * v;
	                } else {
	                    var w = pixelLength / this.maxTextLines;
	                    this.contentSize.width = w;
	                    this.contentSize.height = this.lineHeight * this.maxTextLines;

	                    var maxWidth = 300 - this.contentMargin.left - this.contentMargin.right;
	                    if (w > maxWidth) {
	                        this.contentSize.width = maxWidth;
	                    }
	                }
	            }
	            this.contentDiv.innerHTML = this.content;
	            this.contentDiv.style.width = this.contentSize.width + 'px';
	            this.contentDiv.style.height = this.contentSize.height + 'px';
	        }
	    }, {
	        key: 'updateBubbleSize',
	        value: function updateBubbleSize(position) {
	            this.frame.width = this.contentSize.width + this.contentMargin.left + this.contentMargin.right;
	            this.frame.height = this.contentSize.height + this.contentMargin.top + this.contentMargin.bottom;

	            this.frame.x = position.x - this.frame.halfWidth;
	            var spaceHeight = this.frame.height + this.directionOffsetY + this.angleFrame.height;
	            if (position.y < spaceHeight) {
	                this.isUpDirection = true;
	                this.angleFrame.y = position.y + this.directionOffsetY;
	                this.frame.y = this.angleFrame.y + this.angleFrame.height;
	            } else {
	                this.isUpDirection = false;
	                this.frame.y = position.y - spaceHeight;
	                this.angleFrame.y = this.frame.getMaxY();
	            }
	            //计算在 X 轴上 menu 的 frame（rect）在屏幕内
	            this.angleFrame.x = (this.frame.width - this.angleFrame.width) / 2;
	            if (this.frame.x < this.marginLeft) {
	                this.angleFrame.x -= this.marginLeft - this.frame.x;
	                this.frame.x = this.marginLeft;
	            } else if (this.frame.getMaxX() > this.maxFrameX) {
	                this.angleFrame.x += this.frame.getMaxX() - this.maxFrameX;
	                this.frame.x = this.maxFrameX - this.frame.width;
	            }
	            //校验尖角的偏移量
	            this.angleFrame.x = this.validateAngleOffsetX(this.angleFrame.x);
	            this.angleFrame.x += this.frame.x;
	            this.contentDiv.style.top = this.frame.y + this.contentMargin.top + 'px';
	            this.contentDiv.style.left = this.frame.x + this.contentMargin.left + 'px';
	        }

	        //校验尖角的偏移量

	    }, {
	        key: 'validateAngleOffsetX',
	        value: function validateAngleOffsetX(angleOffsetX) {
	            var maxOffsetX = this.frame.width - this.angleFrame.width - this.cornerRadius / 2;

	            if (angleOffsetX > maxOffsetX) {
	                angleOffsetX = maxOffsetX;
	            } else if (angleOffsetX < this.cornerRadius) {
	                angleOffsetX = this.cornerRadius;
	            }
	            return angleOffsetX;
	        }

	        //取得字符串的总像素长度

	    }, {
	        key: 'getTextPixelLength',
	        value: function getTextPixelLength(str) {
	            var pixelLength = 0;
	            for (var index = 0; index < str.length; index++) {
	                var char = str.charAt(index);
	                var charCode = str.charCodeAt(index);
	                if (this.isDbcCase(charCode)) {
	                    pixelLength += this.fontSize / 2 + 2;
	                } else {
	                    pixelLength += this.fontSize;
	                }
	            }
	            return pixelLength;
	        }

	        //判断字符是否为半角

	    }, {
	        key: 'isDbcCase',
	        value: function isDbcCase(c) {
	            if (c >= 32 && c <= 127) {
	                return true;
	            } else if (c >= 65377 && c <= 65439) {
	                return true;
	            }
	            return false;
	        }
	    }, {
	        key: 'createPanel',
	        value: function createPanel(width, height) {
	            var style = 'position:fixed; z-index:20000; top:0px; left:0px; width:' + width + 'px; ' + 'height:' + height + 'px;';
	            return this.createDiv(style);
	        }
	    }, {
	        key: 'createContentDiv',
	        value: function createContentDiv() {
	            var style = 'position:absolute; z-index:2; overflow:auto; font-family: monospace; word-wrap:break-word; word-break:break-all; padding:0px; color:#252525; font-size:' + this.fontSize + 'px; line-height:' + this.lineHeight + 'px; left:' + this.contentMargin.left + 'px; top:' + this.contentMargin.top + 'px;';
	            return this.createDiv(style);
	        }
	    }, {
	        key: 'createDiv',
	        value: function createDiv(style) {
	            var div = document.createElement('div');
	            div.setAttribute('style', style);
	            return div;
	        }
	    }, {
	        key: 'initCanvas',
	        value: function initCanvas() {
	            this.renderer = PIXI.autoDetectRenderer(window.innerWidth, window.innerHeight, {
	                transparent: true,
	                interactive: false,
	                resolution: window.devicePixelRatio
	            });

	            this.renderer.view.setAttribute('style', 'position:absolute; z-index:1; left:0px; top:0px;-webkit-tap-highlight-color:rgba(0, 0, 0, 0); width:' + window.innerWidth + 'px; height: ' + window.innerHeight + 'px');
	            this.panel.appendChild(this.renderer.view);
	            this.stage = new PIXI.Container();
	            this.graphics = new PIXI.Graphics();
	            this.shadow = new PIXI.Graphics();
	        }
	    }, {
	        key: 'updateBubbleGraph',
	        value: function updateBubbleGraph() {
	            this.drawBubbleView(this.shadow, 0x000000);
	            this.drawBubbleView(this.graphics, 0xf8eab5);
	            this.shadow.alpha = 0.1;

	            var offsetY = 2;
	            if (this.isUpDirection) {
	                offsetY = -2;
	            }
	            this.shadow.y = this.graphics.y + offsetY;

	            this.stage.addChildAt(this.shadow, 0);
	            this.stage.addChildAt(this.graphics, 1);
	        }
	    }, {
	        key: 'drawBubbleView',
	        value: function drawBubbleView(graphics, color) {
	            graphics.clear();
	            graphics.beginFill(color);
	            graphics.drawRoundedRect(this.frame.x, this.frame.y, this.frame.width, this.frame.height, this.cornerRadius);

	            var anglePointY = void 0,
	                angleBottomY = void 0;
	            if (this.isUpDirection) {
	                anglePointY = this.angleFrame.y;
	                angleBottomY = this.angleFrame.getMaxY();
	            } else {
	                anglePointY = this.angleFrame.getMaxY();
	                angleBottomY = this.angleFrame.y;
	            }
	            graphics.moveTo(this.angleFrame.x, angleBottomY);
	            graphics.lineTo(this.angleFrame.center.x, anglePointY);
	            graphics.lineTo(this.angleFrame.getMaxX(), angleBottomY);
	            graphics.endFill();
	        }
	    }], [{
	        key: 'sharedInstance',
	        get: function get() {
	            if (!this[singleton]) {
	                this[singleton] = new GLBubbleView(singletonEnforcer);
	            }
	            return this[singleton];
	        }
	    }]);

	    return GLBubbleView;
	}(_GLAnimation2.GLAnimation);

/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.getDivData = getDivData;
	exports.resolveDivData = resolveDivData;
	exports.resolveCommentIcon = resolveCommentIcon;

	var _NoteManager = __webpack_require__(2);

	var _ElementGenerator = __webpack_require__(28);

	var _Utils = __webpack_require__(29);

	var GREN = __webpack_require__(5);

	/**
	 * 通过解析所有字的坐标信息 获取矩形区域的信息
	 * 返回 二维数组[][]
	 */
	function getDivData(coors) {
	    var begin_y = coors[0].y;
	    var divData = [coors[0]];
	    var divDatas = [];
	    if (coors.length === 1) {
	        divDatas.push(divData);
	        return divDatas;
	    }
	    for (var i = 1; i < coors.length; i++) {
	        var coor = coors[i];
	        var y = coor.y;
	        if (begin_y === y) {
	            divData.push(coor);
	        } else {
	            divDatas.push(divData);
	            divData = [coors[i]];
	            begin_y = coors[i].y;
	        }
	        if (i === coors.length - 1) {
	            divDatas.push(divData);
	        }
	    }
	    return divDatas;
	}

	/**
	 * 创建矩形区域
	 */
	function resolveDivData(divDatas, groupId) {
	    if (!divDatas || divDatas.length === 0) {
	        return null;
	    }

	    //笔记区域点击后的回调

	    var callback = function callback(evt) {
	        _Utils.Utils.stopAndPrevent(evt);
	        _NoteManager.NoteManager.sharedInstance.currentGroupID = evt.target.groupId;
	        //show menu
	        var rect = evt.target.getBoundingClientRect();
	        var offsetY = _NoteManager.NoteManager.sharedInstance.view.book.padding.top;
	        var position = new GREN.Vector2(rect.left + rect.width / 2, rect.top + offsetY);
	        _NoteManager.NoteManager.sharedInstance.popMenu.ifNeedsDisplay(position);
	    };

	    var divs = [];
	    for (var i = 0; i < divDatas.length; i++) {
	        var div = (0, _ElementGenerator.createLineElement)(groupId, divDatas[i]);
	        div.addEventListener('touchend', callback, false);
	        div.addEventListener('touchstart', _Utils.Utils.stopAndPrevent, false);
	        divs.push(div);
	    }

	    return divs;
	}

	/**
	 * 创建划线笔记后的小圆点
	 */
	function resolveCommentIcon(data, comment, groupId) {
	    if (!comment || comment.trim().length === 0 || data.length === 0) {
	        return null;
	    }
	    var icon = (0, _ElementGenerator.createNoteIconButton)(groupId);
	    icon.addEventListener('touchstart', _Utils.Utils.stopAndPrevent, false);
	    icon.addEventListener('touchend', function (evt) {
	        _Utils.Utils.stopAndPrevent(evt);
	        _NoteManager.NoteManager.sharedInstance.currentGroupID = groupId;
	        var newComment = _NoteManager.NoteManager.sharedInstance.noteList.getComment(groupId);
	        var rect = icon.getBoundingClientRect();
	        var offsetY = _NoteManager.NoteManager.sharedInstance.view.book.padding.top;
	        var position = new GREN.Vector2(rect.left + 15, rect.top + 15 + offsetY);
	        GLBubbleView.sharedInstance.ifNeedsDisplay(newComment, position, _NoteManager.NoteManager.sharedInstance.editANote, null);
	        //BubbleView.sharedInstance.ifNeedsDisplay(newComment, position, NoteManager.sharedInstance.editANote, null);
	    }, false);

	    var book = _NoteManager.NoteManager.sharedInstance.view.book;
	    var dataItem = data[data.length - 1];
	    icon.style.top = Math.floor(dataItem.y + dataItem.height) - 16 + 'px';
	    icon.style.left = (book.currentChapter.chapterPos - 1) * book.pageWidth + dataItem.x + dataItem.width - 11 + 'px';
	    //icon.style.left =  dataItem.x + dataItem.width - 11 + 'px';

	    return icon;
	}

/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.createNoteIconButton = createNoteIconButton;
	exports.createLineElement = createLineElement;

	var _NoteManager = __webpack_require__(2);

	//笔记汽泡触发
	function createNoteIconButton(groupId) {

	    var icon = document.createElement('div');
	    icon.groupId = groupId;
	    icon.setAttribute('style', 'width:32px;height:32px;position:absolute;padding:0px;');
	    icon.innerHTML = '<div style="background-color:#fd7222; display:block; margin:11px; width:10px; height:10px; border: 1px #e35263 solid; -moz-border-radius: 6px; -webkit-border-radius: 6px; border-radius:6px;text-align:center; line-height:8px; font-size:8px; color:#fafafa">…</div>';
	    return icon;
	}

	//创建下划线
	function createLineElement(groupId, data) {
	    var div = document.createElement('div');
	    div.groupId = groupId;

	    var book = _NoteManager.NoteManager.sharedInstance.view.book;
	    var width = void 0;
	    if (data.length == 1) {
	        width = data[0].width;
	    } else {
	        var length = data.length;
	        var endX = data[length - 1].x;
	        //中止矩形x - 起始矩形x + 最后一个矩形的宽度
	        width = endX - data[0].x + data[length - 1].width;
	    }
	    div.style.width = width + 'px';
	    div.style.height = data[0].height + 'px';
	    div.style.top = data[0].y + 'px';
	    div.style.left = (book.currentChapter.chapterPos - 1) * book.pageWidth + data[0].x + 'px';
	    //div.style.left = data[0].x + 'px';

	    div.style.borderBottom = '2px solid rgb(255, 96, 0)';
	    div.style.position = 'absolute';
	    return div;
	}

/***/ },
/* 29 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * Created by grenlight on 16/1/12.
	 */

	var Utils = exports.Utils = function () {
	    function Utils() {
	        _classCallCheck(this, Utils);
	    }

	    _createClass(Utils, null, [{
	        key: "stopAndPrevent",
	        value: function stopAndPrevent(evt) {
	            evt.stopPropagation();
	            evt.preventDefault();
	        }

	        //延时执行

	    }, {
	        key: "delay",
	        value: function delay(func) {
	            var timeInterval = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];

	            setTimeout(func, timeInterval);
	        }
	    }]);

	    return Utils;
	}();

/***/ },
/* 30 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var NoteList = exports.NoteList = function () {
	    function NoteList() {
	        _classCallCheck(this, NoteList);

	        this.list = [];
	    }

	    _createClass(NoteList, [{
	        key: "clear",
	        value: function clear() {
	            this.list = [];
	        }
	    }, {
	        key: "add",
	        value: function add(note) {
	            this.list[note.groupId] = note;
	        }
	    }, {
	        key: "update",
	        value: function update(groupId, comment) {
	            var note = this.list[groupId];
	            note.comment = comment;
	        }
	    }, {
	        key: "delete",
	        value: function _delete(groupId) {
	            this.list[groupId] = null;
	        }
	    }, {
	        key: "getComment",
	        value: function getComment(groupId) {
	            var note = this.list[groupId];
	            return note.comment;
	        }
	    }, {
	        key: "getNote",
	        value: function getNote(groupId) {
	            return this.list[groupId];
	        }
	    }]);

	    return NoteList;
	}();

/***/ },
/* 31 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * Created by wangwy on 15-9-24.
	 */
	var xhr = null;

	var Core = exports.Core = function () {
	    function Core() {
	        _classCallCheck(this, Core);
	    }

	    _createClass(Core, null, [{
	        key: "prefixed",

	        /**
	         * 根据各个浏览器添加样式的前缀
	         * @param unprefixed
	         * @returns {*}
	         */
	        value: function prefixed(unprefixed) {
	            var vendors = ["Webkit", "Moz", "O", "ms"],
	                upper = unprefixed[0].toUpperCase() + unprefixed.slice(1),
	                length = vendors.length;

	            if (typeof document.body.style[unprefixed] != 'undefined') {
	                return unprefixed;
	            }

	            for (var i = 0; i < length; i++) {
	                if (typeof document.body.style[vendors[i] + upper] != 'undefined') {
	                    return vendors[i] + upper;
	                }
	            }

	            return unprefixed;
	        }
	    }, {
	        key: "request",


	        /**
	         * 与后台接口
	         * @param url
	         */
	        value: function request(url, completion) {
	            Core.requestPainText(url, function (text, error) {
	                var dom = null;
	                if (text) {
	                    dom = new DOMParser().parseFromString(text, 'text/xml');
	                }
	                completion(dom, error);
	            });
	        }
	    }, {
	        key: "requestPainText",
	        value: function requestPainText(url, completion) {
	            if (xhr === null) {
	                xhr = new XMLHttpRequest();
	                xhr.overrideMimeType('text/xml');
	            }
	            xhr.onreadystatechange = handler;
	            function handler() {
	                if (this.readyState === this.DONE) {
	                    var text = null,
	                        error = null;
	                    if (this.status === 200 || this.status === 0) {
	                        text = this.responseText;
	                    } else {
	                        error = this.response;
	                    }
	                    completion(text, error);
	                }
	            }
	            xhr.open("GET", url, true);
	            xhr.send();
	        }

	        /**
	         * 解析url
	         * @param url
	         * @returns {{protocol: string, host: string, path: string, origin: string, directory: string, base: string, filename: string, extension: string, fragment: string, href: *}}
	         */

	    }, {
	        key: "uri",
	        value: function uri(url) {
	            var uri = {
	                protocol: '',
	                host: '',
	                path: '',
	                origin: '',
	                directory: '',
	                base: '',
	                filename: '',
	                extension: '',
	                fragment: '',
	                href: url
	            },
	                blob = url.indexOf('blob:'),
	                doubleSlash = url.indexOf('://'),
	                search = url.indexOf('?'),
	                fragment = url.indexOf('#'),
	                withoutProtocol,
	                dot,
	                firstSlash;
	            if (blob === 0) {
	                uri.protocol = "blob";
	                uri.base = url.indexOf(0, fragment);
	                return uri;
	            }

	            if (fragment != -1) {
	                uri.fragment = url.slice(fragment + 1);
	                url = url.slice(0, fragment);
	            }

	            if (search != -1) {
	                uri.search = url.slice(search + 1);
	                url = url.slice(0, search);
	            }

	            if (doubleSlash != -1) {
	                uri.protocol = url.slice(0, doubleSlash);
	                withoutProtocol = url.slice(doubleSlash + 3);
	                firstSlash = withoutProtocol.indexOf('/');

	                if (firstSlash === -1) {
	                    uri.host = uri.path;
	                    uri.path = "";
	                } else {
	                    uri.host = withoutProtocol.slice(0, firstSlash);
	                    uri.path = withoutProtocol.slice(firstSlash);
	                }

	                uri.origin = uri.protocol + "://" + uri.host;
	                uri.directory = Core.folder(uri.path);
	                uri.base = uri.origin + uri.directory;
	            } else {
	                uri.path = url;
	                uri.directory = Core.folder(url);
	                uri.base = uri.directory;
	            }

	            uri.filename = url.replace(uri.base, '');
	            dot = uri.filename.lastIndexOf('.');

	            if (dot != -1) {
	                uri.extension = uri.filename.slice(dot + 1);
	            }

	            return uri;
	        }
	    }, {
	        key: "folder",


	        /**
	         * 获取文件目录
	         * @param url
	         * @returns {string}
	         */
	        value: function folder(url) {
	            var lastSlash = url.lastIndexOf('/');
	            var folder = '';
	            if (lastSlash != -1) {

	                folder = url.slice(0, lastSlash + 1);
	            }

	            return folder;
	        }
	    }, {
	        key: "resolveUrl",


	        /**
	         * 根据path获取相对路径
	         * @param base
	         * @param path
	         * @returns {*}
	         */
	        value: function resolveUrl(base, path) {
	            var url,
	                segments = [],
	                uri = Core.uri(path),
	                folders = base.split("/"),
	                paths;
	            if (uri.host) {
	                return path;
	            }

	            folders.pop();

	            paths = path.split("/");
	            paths.forEach(function (p) {
	                if (p === "..") {
	                    folders.pop();
	                } else {
	                    segments.push(p);
	                }
	            });

	            url = folders.concat(segments);

	            return url.join("/");
	        }
	    }, {
	        key: "uuid",


	        /**
	         * 形成唯一标识
	         * @returns {string}
	         */
	        value: function uuid() {
	            var d = new Date().getTime();
	            var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
	                var r = (d + Math.random() * 16) % 16 | 0;
	                d = Math.floor(d / 16);
	                return (c == 'x' ? r : r & 0x7 | 0x8).toString(16);
	            });
	            return uuid;
	        }
	    }, {
	        key: "postMessageToMobile",


	        /**
	         * 向手机端发送消息
	         * @param msgType
	         * @param info
	         */
	        value: function postMessageToMobile(msgType, info) {
	            //console.log("postMessageToMobile:"+msgType);
	            var userAgent = navigator.userAgent || navigator.vendor || window.opera;
	            try {
	                if (userAgent.match(/iPad/i) || userAgent.match(/iPhone/i) || userAgent.match(/iPod/i)) {
	                    window.webkit.messageHandlers.app.postMessage({ msgType: msgType, info: info });
	                } else if (userAgent.match(/Android/i)) {
	                    window.androidApp.postMessage(JSON.stringify({ msgType: msgType, info: info }));
	                }
	            } catch (e) {
	                //    console.error(e);
	            }
	        }
	    }, {
	        key: "nsResolver",


	        /**
	         * 根据前缀获取xpath的命名空间
	         * @param prefix
	         * @returns {*|null}
	         */
	        value: function nsResolver(prefix) {
	            var ns = {
	                'xhtml': 'http://www.w3.org/1999/xhtml',
	                'epub': 'http://www.idpf.org/2007/ops'
	            };
	            return ns[prefix] || null;
	        }
	    }, {
	        key: "indexOfTextNode",


	        /**
	         * 获取textNode在父元素里的位置
	         * @param textNode
	         * @returns {number}
	         */
	        value: function indexOfTextNode(textNode) {
	            var parent = textNode.parentNode;
	            var children = parent.childNodes;
	            var sib;
	            var index = -1;
	            for (var i = 0; i < children.length; i++) {
	                sib = children[i];
	                if (sib.nodeType === Node.TEXT_NODE) {
	                    index++;
	                }
	                if (sib == textNode) break;
	            }
	            return index;
	        }
	    }, {
	        key: "values",


	        /**
	         * 获取对象里的值
	         * @param object
	         * @returns {*}
	         */
	        value: function values(object) {
	            var index = -1;
	            var props, length, result;
	            if (!object) return [];
	            props = Object.keys(object);
	            length = props.length;
	            result = Array(length);

	            while (++index < length) {
	                result[index] = object[props[index]];
	            }

	            return result;
	        }
	    }]);

	    return Core;
	}();

/***/ },
/* 32 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var DomUtil = exports.DomUtil = function () {
	    function DomUtil() {
	        _classCallCheck(this, DomUtil);
	    }

	    _createClass(DomUtil, null, [{
	        key: "getSelection",
	        value: function getSelection(view) {
	            var window_ = view.element.contentWindow;
	            var selection;
	            if (window_.getSelection) {
	                selection = window_.getSelection();
	            } else if (this.doc.selection) {
	                selection = this.doc.selection.createRange().text;
	            }
	            return selection;
	        }
	        /**
	         * 根据位置信息找到目标节点
	         @param root 父节点
	         @param info 位置信息[1,2,3,4]
	         */

	    }, {
	        key: "findNode",
	        value: function findNode(root, info) {
	            var sibling = root;
	            if (!info || info.length === 0) {
	                return root;
	            }
	            for (var i = 0; i < info.length; i++) {
	                sibling = sibling.firstChild;
	                for (var j = 1; j < info[i]; j++) {
	                    sibling = sibling.nextSibling;
	                }
	            }
	            return sibling;
	        }
	        /**
	         * 给定父节点及其子元素,获取其子元素的位置信息
	         */

	    }, {
	        key: "getPosition",
	        value: function getPosition(root, child) {
	            var data = [];
	            //1.获取深度
	            var depth = DomUtil.getDepth(root, child);
	            while (depth > 0) {
	                var width = DomUtil.getWidth(child);
	                data.push(width);
	                child = child.parentElement;
	                depth--;
	            }
	            //2.反转数组
	            //
	            data.reverse();
	            return data;
	        }
	        /**
	         * 获取给定元素是其直接父元素的第几个孩子
	         */

	    }, {
	        key: "getWidth",
	        value: function getWidth(ele) {
	            var width = 1;
	            if (!ele) {
	                throw new Error("child and parent can't be null");
	            }
	            var parent = ele.parentElement;
	            if (!parent) {
	                return -1;
	            }
	            var child = parent.firstChild;
	            // var width = 0;
	            while (child && child != ele) {
	                child = child.nextSibling;
	                width++;
	            }
	            return width;
	        }
	        /**
	         * 获取子元素在其父元素中的深度
	         */

	    }, {
	        key: "getDepth",
	        value: function getDepth(parent, child) {
	            var depth = 1;
	            if (!child || !parent) {
	                throw new Error("child and parent can't be null");
	            }
	            if (parent == child) {
	                return 0;
	            }
	            while (child.parentElement != parent) {
	                child = child.parentElement;
	                depth++;
	            }
	            return depth;
	        }
	        /**
	         * 获取某元素中的所有子TextNode节点
	         */

	    }, {
	        key: "getAllTextNode",
	        value: function getAllTextNode(parent) {
	            var treeWalker = document.createTreeWalker(parent, NodeFilter.SHOW_TEXT, { acceptNode: function acceptNode(node) {
	                    if (node && node.nodeType === 3 && node.textContent.trim()) return NodeFilter.FILTER_ACCEPT;
	                    return NodeFilter.FILTER_REJECT;
	                }
	            }, false);
	            var nodeList = [];
	            do {
	                var node = treeWalker.currentNode;
	                //currentNode可能为textNode 而nextNode()为false
	                if (node && node.nodeType === 3 && node.textContent.trim()) nodeList.push(node);
	            } while (treeWalker.nextNode());
	            return nodeList;
	        }
	        /**
	         * 解析选中元素每个字的坐标
	         */

	    }, {
	        key: "getCoordinate",
	        value: function getCoordinate(doc, startContainer, endContainer, startOffset, endOffset, nodes) {

	            function _getCoordinate(node, start, end, range) {
	                range.setStart(node, start);
	                range.setEnd(node, end);
	                var rect = range.getBoundingClientRect();
	                return {
	                    x: rect.left,
	                    y: rect.top,
	                    height: rect.height,
	                    width: rect.width
	                };
	            }

	            function getCoordinateByNode(node, startOffset, endOffset) {
	                var coors = [];
	                var range_ = doc.createRange();
	                for (var i = startOffset; i < endOffset; i++) {
	                    var c = _getCoordinate(node, i, i + 1, range_);
	                    coors.push(c);
	                }
	                return coors;
	            }

	            var coordinate = [];
	            //是否是起始节点与中止节点之间的文本节点
	            var validNode = false;
	            //起始节点与结束节点是同一节点
	            if (startContainer === endContainer) {
	                return getCoordinateByNode(startContainer, startOffset, endOffset);
	            } else {
	                //不是同一节点
	                for (var i = 0; i < nodes.length; i++) {
	                    var node = nodes[i];
	                    if (node === startContainer) {
	                        validNode = true;
	                        var c = getCoordinateByNode(node, startOffset, startContainer.textContent.length);
	                        coordinate = coordinate.concat(c);
	                    } else if (node === endContainer) {
	                        validNode = false;
	                        var c = getCoordinateByNode(node, 0, endOffset);
	                        coordinate = coordinate.concat(c);
	                        break;
	                    } else if (validNode) {
	                        var c = getCoordinateByNode(node, 0, node.textContent.length);
	                        coordinate = coordinate.concat(c);
	                    }
	                }
	            }

	            return coordinate;
	        }
	    }]);

	    return DomUtil;
	}();

/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.Hooks = exports.HooksKey = undefined;

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Created by wangwy on 15-10-26.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */


	var _Core = __webpack_require__(31);

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var _Symbol = __webpack_require__(8);
	var singleton = _Symbol();
	var singletonEnforcer = _Symbol();

	var HooksKey = exports.HooksKey = {
	    BEFORE_DISPLAY: 'beforeChapterDisplay',
	    BEFORE_FORMAT: 'beforeFormat'
	};

	var Hooks = exports.Hooks = function () {
	    function Hooks(enforcer) {
	        _classCallCheck(this, Hooks);

	        if (enforcer !== singletonEnforcer) {
	            throw 'Hooks是个单例类.';
	        } else {
	            this.hooks = {};
	            this.hooks[HooksKey.BEFORE_DISPLAY] = [];
	            this.hooks[HooksKey.BEFORE_FORMAT] = [];
	        }
	    }

	    _createClass(Hooks, [{
	        key: 'registerHook',


	        /**
	         * 注册hook
	         * @param type
	         * @param toAdd
	         * @param toFront
	         */
	        value: function registerHook(type, toAdd, toFront) {
	            var _this = this;

	            if (typeof this.hooks[type] != "undefined") {
	                (function () {
	                    var addHook = function addHook(hook) {
	                        if (toFront) {
	                            Hooks.instance.hooks[type].unshift(hook);
	                        } else {
	                            Hooks.instance.hooks[type].push(hook);
	                        }
	                    };

	                    if (typeof toAdd === "function") {
	                        addHook(toAdd);
	                    } else if (Array.isArray(toAdd)) {
	                        toAdd.forEach(function (hook) {
	                            addHook(hook);
	                        }, _this);
	                    } else {
	                        _this.hooks[type] = [toAdd];
	                    }
	                })();
	            }
	        }

	        /**
	         * 触发注册完的函数
	         * @returns {boolean}
	         */

	    }, {
	        key: 'triggerHooks',
	        value: function triggerHooks() {
	            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	                args[_key] = arguments[_key];
	            }

	            var hooks,
	                type = args.shift();
	            if (typeof this.hooks[type] == "undefined") return false;

	            hooks = this.hooks[type];
	            hooks.forEach(function (hook) {
	                hook(args);
	            });
	        }
	    }], [{
	        key: 'instance',
	        get: function get() {
	            if (!this[singleton]) {
	                this[singleton] = new Hooks(singletonEnforcer);
	            }
	            return this[singleton];
	        }
	    }]);

	    return Hooks;
	}();

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }(); /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * Created by wangwy on 15-10-26.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          */


	var _Hooks = __webpack_require__(33);

	/**
	 * to do list
	 * 只设宽度等图片加载完，这种方法会导致大量的重排
	 */
	_Hooks.Hooks.instance.registerHook(_Hooks.HooksKey.BEFORE_FORMAT, function (args) {
	    var _args = _slicedToArray(args, 3);

	    var doc = _args[0];
	    var maxWidth = _args[1];
	    var maxHeight = _args[2];
	    //let items = doc.querySelectorAll("img");

	    var items = doc.getElementsByTagName('img');
	    //Array.from 是 es 6 才有的写法, babel 默认无法处理
	    //let imgList = Array.from(items);
	    var imgList = Array.prototype.slice.call(items);

	    //会引起repaint的地方
	    imgList.forEach(function (image) {
	        // -6 是个经验值, 解决 一些 Android 设备上图片被骗分割的问题
	        image.style.maxHeight = maxHeight - 6 + "px";
	        image.style.maxWidth = maxWidth + "px";
	        // let itemRect = image.getBoundingClientRect(),
	        //     rectHeight = itemRect.height,
	        //     rectWidth = itemRect.width,
	        //     top = itemRect.top;
	        // if (top < 0) top = 0;
	        // if (rectHeight + top >= maxHeight || rectWidth >= maxWidth) {
	        //     if (top < maxHeight / 2) {
	        //         //let fontSize = Number(getComputedStyle(image, "").fontSize.match(/(\d*(\.\d*)?)px/)[1]);
	        //         //let fontAdjust = fontSize ? fontSize / 2 : 0;
	        //         //let newHeight = maxHeight - top - fontAdjust;
	        //         image.style.maxHeight = (maxHeight - top) + "px";
	        //     }
	        // }
	    });
	});

/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }(); /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * Created by wangwy on 15-12-2.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          */


	var _Hooks = __webpack_require__(33);

	_Hooks.Hooks.instance.registerHook(_Hooks.HooksKey.BEFORE_FORMAT, function (args) {
	    var _args = _slicedToArray(args, 3);

	    var doc = _args[0];
	    var width = _args[1];
	    var height = _args[2];

	    var trans = doc.querySelectorAll("video"),
	        items = Array.prototype.slice.call(trans);

	    items.forEach(function (item) {
	        item.style.maxWidth = width + "px";
	        item.setAttribute("controls", "controls");
	        item.style["WebkitColumnBreakBefore"] = "always";
	        item.style["breakBefore"] = "always";
	    });
	});

	_Hooks.Hooks.instance.registerHook(_Hooks.HooksKey.BEFORE_FORMAT, function (args) {
	    var _args2 = _slicedToArray(args, 3);

	    var doc = _args2[0];
	    var width = _args2[1];
	    var height = _args2[2];

	    var trans = doc.querySelectorAll("audio"),
	        items = Array.prototype.slice.call(trans);

	    items.forEach(function (item) {
	        item.style.maxWidth = width + "px";
	        item.setAttribute("controls", "controls");
	    });
	});

/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	     value: true
	});
	exports.initReader = initReader;
	exports.gotoHref = gotoHref;
	exports.gotoPage = gotoPage;
	exports.gotoNote = gotoNote;
	exports.gotoOffset = gotoOffset;
	exports.searchText = searchText;
	exports.gotoSearchText = gotoSearchText;
	exports.getCurrentPos = getCurrentPos;
	exports.resetFontSize = resetFontSize;
	exports.resetFontFamily = resetFontFamily;
	exports.setNightMode = setNightMode;
	exports.addCss = addCss;
	exports.removeCss = removeCss;
	exports.showBookNum = showBookNum;
	exports.configPageFlip = configPageFlip;

	var _Reader = __webpack_require__(37);

	var _PageTurning = __webpack_require__(55);

	/**
	 * Created by wangwy on 15-10-16.
	 */

	var reader = void 0;

	function initReader(options) {
	     var isInApp = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];

	     reader = new _Reader.Reader(options, isInApp);
	     reader.renderTo();
	}

	//章节跳转
	function gotoHref(url) {
	     reader.gotoHref(url);
	}
	//页码跳转
	function gotoPage(spinePos, pageNum) {
	     reader.gotoPage(spinePos, pageNum);
	}

	//笔记跳转
	function gotoNote(spinePos, parentPosition, startContainerPosition, offset) {
	     reader.gotoNote(spinePos, parentPosition, startContainerPosition, offset);
	}

	//基于偏移量的跳转
	function gotoOffset(spinePos, offset) {
	     reader.gotoOffset(spinePos, offset);
	}

	function searchText(text) {
	     reader.searchText(text);
	}

	//跳转到搜索结果页
	function gotoSearchText(spinePos, xPath, offset, text) {
	     reader.gotoSearchText(spinePos, xPath, offset, text);
	}

	//获取当前页信息
	function getCurrentPos() {
	     reader.getCurrentPos();
	}

	//设置阅读界面字号(放大, 缩小)
	function resetFontSize(size) {
	     var chaptersNum = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

	     return reader.resetFontSize(size, chaptersNum);
	}

	//设置阅读界面字体
	function resetFontFamily(family) {
	     var chaptersNum = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

	     return reader.resetFontFamily(family, chaptersNum);
	}

	//设置夜间模式
	function setNightMode(isNightMode) {
	     reader.setNightMode(isNightMode);
	}

	//添加CSS
	function addCss(cssPath) {
	     reader.addCss(cssPath);
	}

	function removeCss(cssPath) {
	     reader.removeCss(cssPath);
	}

	function showBookNum() {
	     reader.showBookNum();
	}
	window.showBookNum = showBookNum;

	// 仿真翻页
	function configPageFlip(container) {
	     var transition = new _PageTurning.PageTurning(container.offsetWidth, container.offsetHeight);
	     container.appendChild(transition.domElement);
	}

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.Reader = undefined;

	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Created by wangwy on 15-9-24.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */


	var _Core = __webpack_require__(31);

	var _Renderer = __webpack_require__(38);

	var _Hooks = __webpack_require__(33);

	var _Replace = __webpack_require__(45);

	var _explain = __webpack_require__(46);

	var _DomUtil = __webpack_require__(32);

	var _Iframe = __webpack_require__(47);

	var _Utils = __webpack_require__(29);

	var _Epub = __webpack_require__(49);

	var _DecryptedCaches = __webpack_require__(48);

	var _TouchEventListener = __webpack_require__(54);

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var GREN = __webpack_require__(5);

	var Reader = exports.Reader = function () {
	    function Reader(options) {
	        var isInApp = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];

	        _classCallCheck(this, Reader);

	        this.book = new _Epub.Epub(this, options);
	        this.iframeObj = new _Iframe.Iframe(this.book);

	        this.bookPage = document.getElementById("bookPage");
	        this.registerReplacements();

	        this.element = document.body;
	        var screenSize = this.element.getBoundingClientRect();
	        this.book.setPageDimensions(screenSize);

	        // 添加container
	        this.container = this.createContainer();
	        this.element.appendChild(this.container);

	        this.renderer = new _Renderer.Renderer(this.book, this.iframeObj, this.container);

	        this.addEventListeners = _TouchEventListener.addEventListeners.bind(this);
	    }

	    /**
	     * 初始化容器
	     * @returns {HTMLElement}
	     */


	    _createClass(Reader, [{
	        key: 'createContainer',
	        value: function createContainer() {
	            var container = void 0;

	            var elements = document.getElementsByClassName("epub-container");
	            if (elements.length > 0) {
	                container = elements[0];
	            } else {
	                container = document.createElement("div");
	            }

	            container.setAttribute("class", "epub-container");
	            container.setAttribute('style', 'font-size:0px; word-spacing:0; line-height: 0px; vertical-align:top\n              -webkit-tap-highlight-color:rgba(0, 0, 0, 0);\n       position:absolute; left:0px; overflow-y:hidden; top:' + this.book.padding.top + "px; width:" + this.book.pageWidth + 'px; height:' + this.book.pageHeight + 'px;');

	            return container;
	        }

	        /**
	         * 初始化显示区域
	         * @param eleId
	         */

	    }, {
	        key: 'renderTo',
	        value: function renderTo() {
	            var reader = this;
	            this.displayChapter(this.book.currentChapter, null, true).then(function (result) {
	                function finished() {
	                    _Core.Core.postMessageToMobile("initReader", { initReader: "finished" });
	                    reader.preLoadChapter(reader.book.currentChapter);
	                }
	                if (!Object.keys(reader.book.chaptersNum).length) {
	                    reader.book.calculateTotalPage(function () {
	                        finished();
	                    });
	                } else {
	                    finished();
	                }
	            });
	        }

	        /**
	         * 展示章节
	         * @param goto
	         * @param beforeDisplayFunc {Function} 显示之前的逻辑
	         * @returns {deferred.promise|*}
	         */

	    }, {
	        key: 'displayChapter',
	        value: function displayChapter() {
	            var chapter = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];
	            var beforeDisplayFunc = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	            var isLaunching = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];

	            if (chapter === null) {
	                chapter = this.book.currentChapter;
	            }

	            var that = this;
	            return new Promise(function (resolve) {
	                that.book.enableUserInteraction = false;
	                _Core.Core.postMessageToMobile("chapterDisplayStart", { spinePos: chapter.spinePos });
	                that.renderer.displayChapter(chapter, beforeDisplayFunc).then(function () {
	                    that.addEventListeners();
	                    _Core.Core.postMessageToMobile("chapterDisplayEnd", { spinePos: chapter.spinePos });
	                    that.book.enableUserInteraction = true;

	                    resolve(that.renderer);

	                    if (isLaunching === false) {
	                        _Utils.Utils.delay(function () {
	                            that.preLoadChapter(chapter);
	                        }, 200);
	                    }
	                });
	            });
	        }

	        // 章节预加载

	    }, {
	        key: 'preLoadChapter',
	        value: function preLoadChapter(chapter) {
	            if (this.book.isEncrypted) {
	                var nextChapter = this.book.getChapterByIndex(chapter.spinePos + 1);
	                var preChapter = this.book.getChapterByIndex(chapter.spinePos - 1);
	                _DecryptedCaches.DecryptedCaches.sharedInstance.getHTMLStr(nextChapter.absolute, nextChapter.spinePos, this.book.decryptKey);
	                _DecryptedCaches.DecryptedCaches.sharedInstance.getHTMLStr(preChapter.absolute, preChapter.spinePos, this.book.decryptKey);
	            }
	        }

	        /**
	         * 显示页码
	         */

	    }, {
	        key: 'showBookNum',
	        value: function showBookNum() {
	            if (Object.keys(this.book.chaptersNum).length) {
	                var pageNumber = this.book.currentPageNumber;
	                this.bookPage.textContent = pageNumber + "/" + this.book.chaptersNum.allNum;
	            }
	        }

	        /**
	         * 根据链接跳转到相应的页面
	         * @param url
	         */

	    }, {
	        key: 'gotoHref',
	        value: function gotoHref(url) {
	            var _this = this;

	            var split = url.split("#");
	            var relativeURL = split[0].split('/').pop();
	            var section = split[1] || false;

	            var spinePos = this.book.spineIndexByURL(relativeURL);

	            if (!this.book.isCurrentChapter(spinePos)) {
	                (function () {
	                    var chapter = _this.book.updateCurrentChapter(spinePos);
	                    _this.displayChapter(chapter, function () {
	                        if (section) {
	                            chapter.chapterPos = _this.iframeObj.getPageNumberByElementID(section);
	                            _this.book.currentOffset = 0;
	                        }
	                    });
	                })();
	            } else {
	                if (section) {
	                    var chapterPos = this.iframeObj.getPageNumberByElementID(section);
	                    this.renderer.page(chapterPos);
	                }
	            }
	        }

	        /**
	         * 根据页码跳转到相应页面
	         * @param spinePos
	         * @param pageNum
	         */

	    }, {
	        key: 'gotoPage',
	        value: function gotoPage(spinePos, pageNum) {
	            var _this2 = this;

	            if (!this.book.isCurrentChapter(spinePos)) {
	                (function () {
	                    var chapter = _this2.book.updateCurrentChapter(spinePos);
	                    var pipeFunc = function () {
	                        chapter.chapterPos = pageNum;
	                        this.book.currentOffset = 0;
	                    }.bind(_this2);

	                    _this2.displayChapter(chapter, pipeFunc);
	                })();
	            } else {
	                this.renderer.page(pageNum);
	            }
	        }

	        /**
	         * 根据章节,xpath,偏移量跳转到相应页面
	         * @param spinePos
	         * @param parentPosition
	         * @param startContainerPosition
	         * @param offset
	         * @returns {*}
	         */

	    }, {
	        key: 'gotoNote',
	        value: function gotoNote(spinePos, parentPosition, startContainerPosition, offset) {
	            var _this3 = this;

	            spinePos = parseInt(spinePos);
	            if (!this.book.isValidSpinePos(spinePos)) return;

	            var reader = this;
	            function getChapterPos() {
	                var pPosition = void 0,
	                    sPosition = void 0;
	                if (parentPosition instanceof Array) {
	                    pPosition = parentPosition;
	                    sPosition = startContainerPosition;
	                } else {
	                    pPosition = JSON.parse(parentPosition);
	                    sPosition = JSON.parse(startContainerPosition);
	                }
	                var parent = _DomUtil.DomUtil.findNode(reader.iframeObj.document.body, pPosition);
	                var element = _DomUtil.DomUtil.findNode(parent, sPosition);
	                var range = document.createRange();
	                if (offset) {
	                    range.setStart(element, offset);
	                    range.setEnd(element, element.textContent.length);
	                } else {
	                    range.selectNode(element);
	                }
	                return reader.iframeObj.getPageNumberByRect(range.getBoundingClientRect());
	            };

	            if (this.book.isCurrentChapter(spinePos)) {
	                var chapterPos = getChapterPos();
	                this.renderer.page(chapterPos, 0);
	            } else {
	                (function () {
	                    var chapter = _this3.book.updateCurrentChapter(spinePos);
	                    var pipeFunc = function () {
	                        chapter.chapterPos = getChapterPos();
	                        reader.book.currentOffset = 0;
	                    }.bind(_this3);

	                    _this3.displayChapter(chapter, pipeFunc);
	                })();
	            }
	        }

	        /**
	         * 根据章节,章节偏移量跳转到相应页面
	         * @param spinePos
	         * @param offset
	         * @returns {*}
	         */

	    }, {
	        key: 'gotoOffset',
	        value: function gotoOffset(spinePos) {
	            var offset = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

	            if (!this.book.isValidSpinePos(spinePos)) return;

	            if (!this.book.isCurrentChapter(spinePos)) {
	                var chapter = this.book.updateCurrentChapter(spinePos);
	                var pipeFunc = function () {
	                    this.book.currentOffset = offset;
	                }.bind(this);
	                this.displayChapter(chapter, pipeFunc);
	            } else {
	                if (offset) {
	                    this.renderer.gotoOffset(offset);
	                } else {
	                    this.renderer.firstPage();
	                }
	            }
	        }

	        /**
	         * 查询内容的跳转
	         * @param spinePos
	         * @param xPath
	         * @param offset
	         * @param text
	         * @returns {*}
	         */

	    }, {
	        key: 'gotoSearchText',
	        value: function gotoSearchText(spinePos, xPath, offset, text) {
	            var _this4 = this;

	            if (!this.book.isCurrentChapter(spinePos) && this.book.isValidSpinePos(spinePos)) {
	                (function () {
	                    var chapter = _this4.book.updateCurrentChapter(spinePos);

	                    var pipeFunc = function () {
	                        var _getPageBySearchPath = this.getPageBySearchPath(xPath, offset, text);

	                        var _getPageBySearchPath2 = _slicedToArray(_getPageBySearchPath, 1);

	                        var chapterPos = _getPageBySearchPath2[0];

	                        chapter.chapterPos = chapterPos;
	                        this.book.currentOffset = 0;
	                    }.bind(_this4);

	                    _this4.displayChapter(chapter, pipeFunc).then(function () {
	                        var ele = this.renderer.getElementByXPath(xPath);
	                        this.renderer.highlight(ele, offset, text.length);
	                    }.bind(_this4));
	                })();
	            } else {
	                (function () {
	                    var _getPageBySearchPath3 = _this4.getPageBySearchPath(xPath, offset, text);

	                    var _getPageBySearchPath4 = _slicedToArray(_getPageBySearchPath3, 2);

	                    var chapterPos = _getPageBySearchPath4[0];
	                    var ele = _getPageBySearchPath4[1];

	                    _this4.renderer.page(chapterPos, 0, function () {
	                        _this4.renderer.highlight(ele, offset, text.length);
	                    });
	                })();
	            }
	        }
	    }, {
	        key: 'getPageBySearchPath',
	        value: function getPageBySearchPath(xPath, offset, text) {
	            var ele = this.renderer.getElementByXPath(xPath);
	            var range = document.createRange();
	            range.setStart(ele, offset);
	            range.setEnd(ele, offset + text.length);
	            var page = this.iframeObj.getPageNumberByRect(range.getBoundingClientRect());
	            return [page, ele];
	        }

	        /**
	         * 全局搜索text
	         * @param text
	         * @returns {Promise.promise|*}
	         */

	    }, {
	        key: 'searchText',
	        value: function searchText(text) {
	            var textsMap = [];
	            var reader = this;
	            function operate(content, chapter, index) {
	                if (content) {
	                    var texts = reader.renderer.searchText(text, content, index, chapter.getChapterName());
	                    if (texts) {
	                        textsMap = textsMap.concat(texts);
	                    }
	                    content = null;
	                    if (textsMap.length >= 50) {
	                        // console.log(textsMap);
	                        _Core.Core.postMessageToMobile("searchText", { searchText: textsMap, flag: "1" });
	                        return;
	                    }
	                }
	                //优化内存占用
	                _Utils.Utils.delay(function () {
	                    getSearchText(index + 1);
	                });
	            }
	            function getSearchText(i) {
	                if (reader.book.isValidSpinePos(i)) {
	                    (function () {
	                        var chapter = reader.book.getChapterByIndex(i);
	                        if (reader.book.isEncrypted) {
	                            _DecryptedCaches.DecryptedCaches.sharedInstance.getHTMLStr(chapter.absolute, chapter.spinePos, reader.book.decryptKey, function (htmlStr) {
	                                var content = new DOMParser().parseFromString(htmlStr, 'text/xml');
	                                operate(content, chapter, i);
	                            }, false);
	                        } else {
	                            _Core.Core.request(chapter.absolute, function (content) {
	                                operate(content, chapter, i);
	                            });
	                        }
	                    })();
	                } else {
	                    // console.log(textsMap);
	                    _Core.Core.postMessageToMobile("searchText", { searchText: textsMap, flag: "1" });
	                }
	            }
	            getSearchText(0);
	        }

	        /**
	         * 获取当前位置信息
	         */

	    }, {
	        key: 'getCurrentPos',
	        value: function getCurrentPos() {
	            var pageInfo = this.book.getCurrentPagePos();
	            var chapterName = this.renderer.chapterName.textContent;
	            _Core.Core.postMessageToMobile("currentPos", { spinePos: this.book.currentChapter.spinePos, chapterOffset: pageInfo.start, chapterName: chapterName, context: pageInfo.summary });
	        }

	        /**
	         * 改变字号
	         * @param size
	         */

	    }, {
	        key: 'resetFontSize',
	        value: function resetFontSize(size) {
	            var chaptersNum = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

	            this.book.setFontSize(size, chaptersNum);
	            this.reset();
	        }
	    }, {
	        key: 'resetFontFamily',


	        /**
	         * 改变字体
	         * @param family
	         */
	        value: function resetFontFamily(family) {
	            var chaptersNum = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

	            this.book.setFontFamily(family, chaptersNum);
	            this.reset();
	        }

	        /**
	         * 设置日夜间模式
	         * @param isNightMode
	         */

	    }, {
	        key: 'setNightMode',
	        value: function setNightMode(isNightMode) {
	            if (isNightMode === this.book.nightMode) return;

	            this.book.nightMode = isNightMode;
	            if (isNightMode) {
	                EPUBJS.BookInterface.configBackgroundColor("#252525");
	                this.renderer.setNightMode();
	            } else {
	                EPUBJS.BookInterface.configBackgroundColor("#fafafa");
	                this.renderer.setNightMode();
	            }
	            _Core.Core.postMessageToMobile("setNightMode", { nightMode: isNightMode });
	        }

	        /**
	         * 刷新页面
	         * @returns {!Promise.<RESULT>}
	         */

	    }, {
	        key: 'reset',
	        value: function reset() {
	            this.displayChapter(this.book.currentChapter).then(function () {
	                if (!Object.keys(this.book.chaptersNum).length) {
	                    this.book.calculateTotalPage();
	                }
	            }.bind(this));
	        }

	        /**
	         * 下一页
	         * @returns {*}
	         */

	    }, {
	        key: 'nextPage',
	        value: function nextPage(durTime) {
	            var _this5 = this;

	            if (this.book.isLastPage()) {
	                console.log("isLastPage");
	                this.renderer.currentPage(150);
	            } else {
	                this.book.enableUserInteraction = false;
	                this.renderer.nextPage(durTime, function (isCurrentChapter) {
	                    if (!isCurrentChapter) {
	                        _this5.nextChapter();
	                    }
	                    _this5.book.enableUserInteraction = true;
	                });
	            }
	        }

	        /**
	         * 上一页
	         * @returns {*}
	         */

	    }, {
	        key: 'prevPage',
	        value: function prevPage(durTime) {
	            var _this6 = this;

	            if (!this.book.isFirstPage()) {
	                this.book.enableUserInteraction = false;
	                this.renderer.prevPage(durTime, function (isCurrentChapter) {
	                    if (!isCurrentChapter) {
	                        _this6.prevChapter();
	                    }
	                    _this6.book.enableUserInteraction = true;
	                });
	            } else {
	                this.renderer.currentPage(150);
	            }
	        }

	        /**
	         * 下一章节
	         * @returns {deferred.promise|*}
	         */

	    }, {
	        key: 'nextChapter',
	        value: function nextChapter() {
	            var chapter = this.book.intoNextChapter();
	            if (chapter) {
	                return this.displayChapter(chapter);
	            }
	        }

	        /**
	         * 上一章节
	         * @returns {deferred.promise|*}
	         */

	    }, {
	        key: 'prevChapter',
	        value: function prevChapter() {
	            var chapter = this.book.backToPreChapter();
	            if (chapter) {
	                this.displayChapter(chapter);
	            }
	        }
	    }, {
	        key: 'getTouchPoint',
	        value: function getTouchPoint(event) {
	            var clientX = event.clientX || (event.touches && event.touches.length > 0 ? event.touches[0].clientX : event.changedTouches[0].clientX);
	            var clientY = event.clientY || (event.touches && event.touches.length > 0 ? event.touches[0].clientY : event.changedTouches[0].clientY);
	            return new GREN.Vector2(clientX, clientY);
	        }

	        /**
	         * 添加css样式
	         * @param cssPath
	         * @returns {*|!Promise.<RESULT>|Promise}
	         */

	    }, {
	        key: 'addCss',
	        value: function addCss(cssPath) {
	            this.headTags.push({ link: { href: cssPath, type: "text/css", rel: "stylesheet" } });

	            this.displayChapter(this.book.currentChapter).then(function () {
	                _Core.Core.postMessageToMobile("addCss", { addCss: "addCss" });
	            }.bind(this));
	        }

	        /**
	         * 移除css样式
	         * @param cssPath
	         * @returns {*|!Promise.<RESULT>|Promise}
	         */

	    }, {
	        key: 'removeCss',
	        value: function removeCss(cssPath) {
	            this.headTags.forEach(function (headTag, index) {
	                if (headTag.link) {
	                    if (cssPath === headTag.link["href"]) {
	                        this.headTags.splice(index, 1);
	                    }
	                }
	            }, this);
	            this.displayChapter(this.book.currentChapter).then(function () {
	                _Core.Core.postMessageToMobile("removeCss", { removeCss: "removeCss" });
	            }.bind(this));
	        }

	        /**
	         * 注册hooks回调函数
	         * @param renderer
	         */

	    }, {
	        key: 'registerReplacements',
	        value: function registerReplacements() {
	            var that = this;
	            _Hooks.Hooks.instance.registerHook(_Hooks.HooksKey.BEFORE_DISPLAY, function (args) {
	                _Replace.Replace.Hrefs(args[0], that);
	                _explain.Explain.Abbrs(args[0], that);
	            }, true);
	        }
	    }]);

	    return Reader;
	}();

/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.Renderer = undefined;

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Created by wangwy on 15-9-24.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */


	var _Layout = __webpack_require__(39);

	var _Hooks = __webpack_require__(33);

	var _Core = __webpack_require__(31);

	var _Interface = __webpack_require__(40);

	var _Utils = __webpack_require__(29);

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var Renderer = exports.Renderer = function () {
	    function Renderer(book, iframeObj, container) {
	        _classCallCheck(this, Renderer);

	        this.book = book;
	        this.hidden = false;
	        this.iframeObj = iframeObj;
	        this.container = container;
	        this.resetIframe();
	        this.chapterName = document.getElementById("chapterName");
	    }

	    _createClass(Renderer, [{
	        key: 'resetIframe',
	        value: function resetIframe() {
	            if (this.element) {
	                this.container.removeChild(this.element);
	            }
	            this.element = this.iframeObj.iframe;
	            this.container.appendChild(this.element);

	            this.visible(false);
	        }

	        /**
	         * 隐藏或者显示iframe
	         *
	         * css 动画在 display:none下不会执行
	         * height&&width：0px 后重置  会导致加载出来的html重绘
	         *
	         * 最终方案:
	         * 调整背景层 zIndex 来完成遮挡
	         */

	    }, {
	        key: 'visible',
	        value: function visible(bool) {
	            if (bool === true) {
	                (0, _Interface.bgBackToFloor)();
	            } else if (bool === false) {
	                (0, _Interface.bgBringToFront)();
	            }
	        }
	    }, {
	        key: 'updateChapterNameDisplay',
	        value: function updateChapterNameDisplay(chapter, pg) {
	            this.chapterName.textContent = chapter.getChapterNameBypg(pg) || "";
	        }

	        /**
	         * 显示章节: 根据路径加载页面
	         * @param url
	         * @returns {deferred.promise|*}
	         */

	    }, {
	        key: 'displayChapter',
	        value: function displayChapter(chapter, beforeDisplayFunc) {
	            // 使内容的偏移量归位,否则重绘笔记时拿到的文字坐标可能会不准确.
	            //this.resetIframe();
	            this.visible(false);
	            var pageMapUpdated = false;
	            var renderer = this;
	            return new Promise(function (resolve) {
	                renderer.iframeObj.load(chapter.absolute, chapter.spinePos).then(function () {
	                    if (renderer.book.nightMode) {
	                        renderer.setNightMode();
	                    }
	                    _Hooks.Hooks.instance.triggerHooks(_Hooks.HooksKey.BEFORE_DISPLAY, renderer);

	                    if (beforeDisplayFunc) beforeDisplayFunc();
	                    //更新章节总页码
	                    chapter.updatePageCount(renderer.iframeObj);

	                    var needToPage = 1;
	                    if (renderer.book.currentOffset !== 0) {
	                        if (renderer.book.currentOffset > 0) {
	                            chapter.updatePageMap(renderer.iframeObj);
	                            pageMapUpdated = true;
	                            needToPage = renderer.book.getChapterPosByOffset(renderer.book.currentOffset);
	                            renderer.book.updateCurrentOffset();
	                        } else {
	                            //章节的最后一页
	                            needToPage = chapter.chapterPos = chapter.pageCount;
	                        }
	                    } else {
	                        needToPage = chapter.chapterPos;
	                    }
	                    renderer.updateChapterNameDisplay(chapter, needToPage);

	                    if (needToPage > 1) {
	                        //保证动画完成后再执行回调,否则后面与UI坐标有关的操作可能会导致坐标不准确
	                        renderer.page(needToPage, 0, function (isCurrentChapter) {
	                            nextStep();
	                        });
	                    } else {
	                        nextStep(0);
	                    }
	                });

	                function nextStep() {
	                    var currentOffset = arguments.length <= 0 || arguments[0] === undefined ? -1 : arguments[0];

	                    renderer.visible(true);
	                    //让章节先显示,updatePageMap尽量推后
	                    _Utils.Utils.delay(function () {
	                        if (!pageMapUpdated) {
	                            chapter.updatePageMap(renderer.iframeObj);
	                            /**
	                             *  updateCurrentOffset不能直接放到updatePageMap里
	                             *  因为可能此时的页码与偏移量是不准确的,可能是先有外部提定的offset值,
	                             *  然后需要通过offset计算页码.
	                             */
	                            renderer.book.updateCurrentOffset(currentOffset);
	                        }
	                        resolve();
	                    });
	                };
	            });
	        }

	        /**
	         * 重新格式化页面
	         */

	    }, {
	        key: 'reformat',
	        value: function reformat() {
	            _Layout.Layout.setColumnStyleToElement(this.iframeObj.docEl, this.book);
	            this.book.currentChapter.updatePageMap(this.iframeObj);
	            this.page(this.book.currentChapter.chapterPos, 0);
	        }

	        /**
	         * 下一页
	         * @returns {*}
	         */

	    }, {
	        key: 'nextPage',
	        value: function nextPage(durTime, completion) {
	            var page = this.book.getNextPage();
	            this.page(page, durTime, completion);
	        }

	        /**
	         * 上一页
	         * @returns {*}
	         */

	    }, {
	        key: 'prevPage',
	        value: function prevPage(durTime, completion) {
	            var page = this.book.getPrePage();
	            this.page(page, durTime, completion);
	        }

	        /**
	         * 跳转到第一页
	         */

	    }, {
	        key: 'firstPage',
	        value: function firstPage() {
	            this.page(1, 0);
	        }
	    }, {
	        key: 'gotoOffset',
	        value: function gotoOffset(offset) {
	            var needToPage = this.book.getChapterPosByOffset(offset);
	            this.page(needToPage, 0);
	        }

	        /**
	         * 停留在当前页
	         * @param durTime
	         */

	    }, {
	        key: 'currentPage',
	        value: function currentPage(durTime) {
	            this.page(this.book.currentChapter.chapterPos, durTime);
	        }

	        /**
	         * 根据fragment找到所在的节点
	         * @param fragment
	         */

	    }, {
	        key: 'section',
	        value: function section(fragment) {
	            var el = this.iframeObj.document.getElementById(fragment);
	            if (el) {
	                this.pageByElement(el);
	            }
	        }

	        /**
	         * 根据range跳到相应的页面
	         * @param range
	         */

	    }, {
	        key: 'gotoRange',
	        value: function gotoRange(range) {
	            var completion = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

	            var pg = this.iframeObj.getPageNumberByRect(range.getBoundingClientRect());
	            this.page(pg, 0, completion);
	        }

	        /**
	         * 跳转到el所在的页面
	         * @param el
	         */

	    }, {
	        key: 'pageByElement',
	        value: function pageByElement(el) {
	            var pg = this.iframeObj.getPageNumberByElement(el);
	            this.page(pg, 0);
	        }

	        /**
	         * 根据页码与持续事件跳转到相应的页面
	         * @param pg
	         * @param durTime
	         */

	    }, {
	        key: 'page',
	        value: function page(pg) {
	            var durTime = arguments.length <= 1 || arguments[1] === undefined ? 1 : arguments[1];
	            var completion = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];

	            this.book.enableUserInteraction = false;

	            //如果时间为0的话,不会触发 translationEnd
	            var timeInterval = durTime < 1 ? 1 : durTime;
	            var transitionEvent = this.whichTransitionEvent();

	            var isCurrentChapter = this.book.updateChapterPos(pg);
	            var translationEnd = function () {
	                this.iframeObj.docEl.removeEventListener(transitionEvent, translationEnd, false);
	                if (isCurrentChapter) {
	                    if (pg === 1) {
	                        this.book.updateCurrentOffset(0);
	                    } else {
	                        if (this.book.currentChapter.isPageMapCalculated) {
	                            this.book.updateCurrentOffset();
	                        }
	                    }
	                }
	                if (completion !== null) completion(isCurrentChapter);
	                this.book.enableUserInteraction = true;
	            }.bind(this);

	            this.iframeObj.docEl.addEventListener(transitionEvent, translationEnd, false);
	            if (!this.iframeObj.page(pg, timeInterval)) {
	                if (completion !== null) completion(isCurrentChapter);
	                this.book.enableUserInteraction = true;
	            }

	            if (isCurrentChapter) {
	                this.updateChapterNameDisplay(this.book.currentChapter, pg);
	            }
	        }
	    }, {
	        key: 'whichTransitionEvent',
	        value: function whichTransitionEvent() {
	            var transitions = {
	                'transition': 'transitionend',
	                'MozTransition': 'transitionend',
	                'WebkitTransition': 'webkitTransitionEnd'
	            };

	            for (var t in transitions) {
	                if (this.iframeObj.docEl.style[t] !== undefined) {
	                    return transitions[t];
	                }
	            }
	        }
	        /**
	         * 轮训"query",让它执行"func"函数
	         * @param query
	         * @param func
	         * @param progress
	         */

	    }, {
	        key: 'replace',
	        value: function replace(query, func, progress) {
	            var items = this.iframeObj.docEl.querySelectorAll(query),
	                resources = Array.prototype.slice.call(items),
	                count = resources.length;
	            if (count === 0) {
	                return;
	            }
	            resources.forEach(function (item) {
	                var called = false;
	                var after = function after(result, full) {
	                    if (called === false) {
	                        count--;
	                        if (progress) progress(result, full, count);
	                        if (count <= 0) return;
	                        called = true;
	                    }
	                };

	                func(item, after);
	            }.bind(this));
	        }

	        /**
	         * 获取element的xPath
	         * @param element
	         * @returns {string}
	         */

	    }, {
	        key: 'getXPathByElement',
	        value: function getXPathByElement(element) {
	            var paths = [];
	            var isXhtml = element.ownerDocument.documentElement.getAttribute("xmlns") === "http://www.w3.org/1999/xhtml";
	            var index, nodeName, tagName, pathIndex;
	            if (element.nodeType == Node.TEXT_NODE) {
	                index = _Core.Core.indexOfTextNode(element) + 1;
	                paths.push("text()[" + index + "]");
	                element = element.parentNode;
	            }
	            for (; element && element.nodeType == Node.ELEMENT_NODE; element = element.parentNode) {
	                index = 0;
	                for (var sibling = element.previousSibling; sibling; sibling = sibling.previousSibling) {
	                    //忽略doc的类型声明
	                    if (sibling.nodeType == Node.DOCUMENT_TYPE_NODE) {
	                        continue;
	                    }
	                    if (sibling.nodeName == element.nodeName) {
	                        ++index;
	                    }
	                }
	                nodeName = element.nodeName.toLowerCase();
	                tagName = isXhtml ? "xhtml:" + nodeName : nodeName;
	                pathIndex = index ? "[" + (index + 1) + "]" : "";
	                paths.splice(0, 0, tagName + pathIndex);
	            }
	            return paths.length ? "./" + paths.join("/") : null;
	        }

	        /**
	         * 通过xPath获取element
	         * @param xpath
	         * @returns {Node}
	         */

	    }, {
	        key: 'getElementByXPath',
	        value: function getElementByXPath(xpath) {
	            var startContainer = this.iframeObj.document.evaluate(xpath, this.iframeObj.document, _Core.Core.nsResolver, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue;
	            return startContainer;
	        }

	        /**
	         * 从本页面中查找文本
	         * @param doc
	         * @param text
	         * @param spinePos
	         * @param chapterName
	         * @returns {Array}
	         */

	    }, {
	        key: 'searchText',
	        value: function searchText(text, doc, spinePos, chapterName) {
	            try {
	                var treeWalker = document.createTreeWalker(doc, NodeFilter.SHOW_TEXT, {
	                    acceptNode: function acceptNode(node) {
	                        if (node.textContent.trim().length > 0) {
	                            return NodeFilter.FILTER_ACCEPT;
	                        } else {
	                            return NodeFilter.FILTER_REJECT;
	                        }
	                    }
	                }, false);
	                var node,
	                    offset = -1,
	                    xPath;
	                var results = [];
	                while (node = treeWalker.nextNode()) {
	                    offset = node.textContent.indexOf(text);
	                    if (offset != -1) {
	                        xPath = this.getXPathByElement(node);
	                        results.push({ nodeText: node.textContent, search: text, spinePos: spinePos, chapterName: chapterName, xPath: xPath, offset: offset });
	                    }
	                }
	                return results;
	            } catch (e) {
	                return null;
	            }
	        }

	        /**
	         * 获取坐标
	         * @param node
	         * @param offset
	         * @param length
	         * @returns {Array}
	         */

	    }, {
	        key: 'getHighlightRects',
	        value: function getHighlightRects(node, offset, length) {
	            var range = document.createRange(),
	                rect,
	                endRect = {},
	                map = [];
	            for (var i = offset; i < offset + length; i++) {
	                range.setStart(node, i);
	                range.setEnd(node, i + 1);
	                rect = range.getBoundingClientRect();
	                if (i == offset) {
	                    endRect = rect;
	                    map.push({ start: rect, end: null });
	                } else {
	                    if (rect.top == endRect.top) {
	                        endRect = rect;
	                    } else {
	                        map[map.length - 1].end = endRect;
	                        endRect = rect;
	                        map.push({ start: rect, end: null });
	                    }
	                }
	            }
	            if (endRect) {
	                map[map.length - 1].end = endRect;
	            }
	            return map;
	        }

	        /**
	         * 根据坐标创建div，用于做背景
	         * @param width
	         * @param height
	         * @param left
	         * @param top
	         */

	    }, {
	        key: 'createHighlightDiv',
	        value: function createHighlightDiv(width, height, left, top) {
	            var div = this.iframeObj.document.createElement("div");
	            div.style.position = "absolute";
	            div.style.opacity = "0.16";
	            div.style.width = width + "px";
	            div.style.height = height + "px";
	            div.style.left = left + "px";
	            div.style.top = top + "px";
	            div.style.backgroundColor = "rgb(204,51,0)";
	            div.setAttribute("class", "highlight-search");
	            return div;
	        }

	        /**
	         * 高亮文字
	         * @param node
	         * @param offset
	         * @param length
	         */

	    }, {
	        key: 'highlight',
	        value: function highlight(node, offset, length) {
	            var offsetLeft = (this.book.currentChapter.chapterPos - 1) * this.book.pageWidth;
	            var rectMap = this.getHighlightRects(node, offset, length);
	            var divFrag = document.createDocumentFragment();
	            rectMap.forEach(function (rects) {
	                divFrag.appendChild(this.createHighlightDiv(rects.end.right - rects.start.left, rects.start.height, rects.start.left + offsetLeft, rects.start.top));
	            }, this);
	            this.iframeObj.document.body.appendChild(divFrag);
	        }

	        /**
	         * 清除背景
	         */

	    }, {
	        key: 'unHighlight',
	        value: function unHighlight() {
	            var items = Array.prototype.slice.apply(this.iframeObj.document.body.getElementsByClassName("highlight-search"));
	            items.forEach(function (item) {
	                this.iframeObj.document.body.removeChild(item);
	            }, this);
	        }

	        /**
	         * 设置日夜间模式
	         * @param isNightMode
	         */

	    }, {
	        key: 'setNightMode',
	        value: function setNightMode() {
	            var isNightMode = this.book.nightMode;
	            var styleTag = this.iframeObj.document.getElementById("nightMode");
	            if (isNightMode) {
	                if (!styleTag) {
	                    styleTag = this.iframeObj.document.createElement("style");
	                    styleTag.id = "nightMode";
	                }
	                styleTag.innerHTML = '\n            html,img,video {\n                -webkit-filter:invert(1) hue-rotate(180deg);\n                 filter:invert(1) hue-rotate(180deg);\n             }\n              img,video {\n              -webkit-backface-visibility:hidden;\n              }';
	                this.iframeObj.document.head.appendChild(styleTag);
	            } else {
	                styleTag = this.iframeObj.document.getElementById("nightMode");
	                if (styleTag) {
	                    this.iframeObj.document.head.removeChild(styleTag);
	                }
	            }
	        }
	    }]);

	    return Renderer;
	}();

/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.Layout = undefined;

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Created by wangwy on 15-9-24.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */


	var _Core = __webpack_require__(31);

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var columnStyle = '';
	var calculatedBodyStyle = '';

	var Layout = exports.Layout = function () {
	    function Layout() {
	        _classCallCheck(this, Layout);
	    }

	    _createClass(Layout, null, [{
	        key: 'getColumnStyle',


	        //生成分栏样式
	        value: function getColumnStyle(book) {
	            if (columnStyle.length === 0) {
	                columnStyle = 'width: ' + book.pageWidth + 'px;\n            height: ' + book.pageHeight + 'px;\n            overflow: auto;\n            -webkit-transform: translate3d(0px, 0px, 0px);\n            -webkit-column-axis: horizontal;\n            -webkit-column-fill: auto;\n            -webkit-column-width: ' + book.contentWidth + 'px;\n            -webkit-column-gap: 0px;\n            direction: ltr;\n            ';
	            }
	            return columnStyle;
	        }

	        //生成Body样式:字体字号及边距CSS

	    }, {
	        key: 'calculateBodyStyle',
	        value: function calculateBodyStyle(book) {
	            calculatedBodyStyle = 'margin:0px;\n        -webkit-user-select:text;\n        padding-top:0px;\n        padding-bottom:0px;\n        padding-left:' + book.padding.left + 'px;\n        padding-right:' + book.padding.right + 'px;\n';
	            if (book.fontSize) {
	                calculatedBodyStyle += 'font-size:' + book.fontSize + 'px;';
	            }
	            if (book.fontFamily) {
	                calculatedBodyStyle += 'font-family:' + book.fontFamily;
	            }
	        }

	        // 段落样式（不能影响图片的样式）

	    }, {
	        key: 'paragraphStyle',
	        value: function paragraphStyle() {
	            return 'p, li, span {\n            line-height: 1.5;\n         }';
	        }
	    }, {
	        key: 'getBodyStyle',
	        value: function getBodyStyle() {
	            return calculatedBodyStyle;
	        }
	    }, {
	        key: 'getAbbrStyle',
	        value: function getAbbrStyle() {
	            var calculateAbbrStyle = 'abbr img{width:16px;height:16px;vertical-align:middle;}';
	            return calculateAbbrStyle;
	        }
	        /**
	         * 计算页码
	         * @returns {Number}
	         */

	    }, {
	        key: 'calculatePages',
	        value: function calculatePages(documentElement, book) {
	            //let startTime = (new Date()).getTime();
	            //let rootElement = documentElement.querySelector("body");
	            var rootElement = documentElement.getElementsByTagName("body")[0];
	            if (!rootElement) {
	                return 1;
	            }

	            /**
	             * 这一步操作很耗时,占整个页码计算流程耗时的70%左右(不论是用range还scrollWidth)
	             * 因为 scrollWidth, getBoundingClientRect() 都会导致傻逼浏览器 repaint
	             *
	             * Safari for iOS 对于纯图片的章节总页码计算出来只有一页
	             * 使用 scrollWidth 计算页码可能会导致某些章节多出来最后一页空页页
	             *
	             *
	             * 通过最后一个标签的坐标信息来计算页码数:
	             * 注意点:
	             * 1,结尾标签有可能是空或内容宽度不满一栏
	             * 2,这个标签的内容可能跨栏了
	             * 3,它可能是个embed 标签, 没有 rect 属性, 或者是 br 之类的在 Safari 下 rect 为 0
	             * 4,<div><br></div> 这样的形式在某些机型上 rect 为 0
	             */
	            var lastElement = rootElement.lastElementChild;
	            if (rootElement === null || lastElement === null) {
	                return 1;
	            }
	            function checkLastElement() {
	                var tagName = lastElement.tagName.toLowerCase();
	                // 有一些书在运行时会莫名其妙地插入一个 叫 mbppagebreak 的div, 会导致页码计算出错。
	                var className = lastElement.className;
	                if (tagName === 'embed' || tagName === 'br' || tagName === 'hr' || className === 'mbppagebreak') {
	                    lastElement = lastElement.previousElementSibling;
	                    checkLastElement();
	                }
	            }
	            checkLastElement();

	            /**
	             * 在某些机型上不同标签可能出现 rect 为 0
	             */
	            var lastRect = { left: 0, width: 0 };
	            function calRect() {
	                var range2 = documentElement.ownerDocument.createRange();
	                range2.selectNodeContents(lastElement);
	                lastRect = range2.getBoundingClientRect();
	                if (lastRect.left === 0 && lastRect.width === 0) {
	                    lastElement = lastElement.previousElementSibling;
	                    checkLastElement();
	                    calRect();
	                }
	            }
	            calRect();

	            /**
	             * 在某些 Android 设备上, getBoundingClientRect 拿到的 width 与实际不符
	             * 取 width 用 element.offsetWidth  的话, 在 Safari  上又有问题了, 有时比实际多,有时比实际小
	             */
	            var pageChecked = Math.ceil((lastRect.left + lastRect.width) / book.pageWidth);
	            // let pageChecked2 = Math.ceil((lastRect.left + lastElement.offsetWidth)/book.pageWidth);
	            // console.log('calculatePages:', pageChecked, lastRect)
	            return pageChecked;
	        }
	    }]);

	    return Layout;
	}();

/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.textCopied = textCopied;
	exports.getText = getText;
	exports.createNote = createNote;
	exports.repaintNote = repaintNote;
	exports.updateNote = updateNote;
	exports.configBackgroundColor = configBackgroundColor;
	exports.bgBringToFront = bgBringToFront;
	exports.bgBackToFloor = bgBackToFloor;

	var _NoteManager = __webpack_require__(2);

	var _NoteObject = __webpack_require__(41);

	var _DotMatrixEffect = __webpack_require__(42);

	var _Core = __webpack_require__(31);

	var _DomUtil = __webpack_require__(32);

	//复制文本(复制到系统的剪切板)
	function textCopied() {
	    var selectedRange = _DomUtil.DomUtil.getSelection(_NoteManager.NoteManager.sharedInstance.view);
	    var range = selectedRange.getRangeAt(0);
	    var text = range.toString();
	    _Core.Core.postMessageToMobile('textCopy', text);
	}

	//获取选择的文本(不复制到系统的剪切板)
	function getText() {
	    var selectedRange = _DomUtil.DomUtil.getSelection(_NoteManager.NoteManager.sharedInstance.view);
	    var range = selectedRange.getRangeAt(0);
	    var text = range.toString();

	    _NoteManager.NoteManager.sharedInstance.currentRangeClone = range.cloneRange();
	    _Core.Core.postMessageToMobile('selectedText', text);
	}

	//添加笔记
	function createNote(comment) {
	    var selectedRange = _DomUtil.DomUtil.getSelection(_NoteManager.NoteManager.sharedInstance.view);
	    var range = void 0;
	    if (selectedRange && selectedRange.rangeCount > 0) {
	        range = selectedRange.getRangeAt(0);
	    } else {
	        // 试图从currentRange中读取数据
	        range = _NoteManager.NoteManager.sharedInstance.currentRangeClone;
	    }

	    var note = _NoteObject.NoteObject.createByRange(range, comment);
	    if (!note) {
	        return;
	    }
	    _NoteManager.NoteManager.sharedInstance._applyInlineStyle(note, true);
	    _NoteManager.NoteManager.sharedInstance.noteList.add(note);
	}

	//重绘笔记
	function repaintNote(data) {
	    if (data && data instanceof Array && data.length > 0) {
	        _NoteManager.NoteManager.sharedInstance.noteList.clear();
	        var view = _NoteManager.NoteManager.sharedInstance.view;
	        for (var i = 0; i < data.length; i++) {
	            var noteJSON = data[i];

	            if (noteJSON.index != undefined && noteJSON.index == view.book.currentChapter.spinePos) {
	                (function () {
	                    var note = _NoteObject.NoteObject.createByJSON(noteJSON);
	                    _NoteManager.NoteManager.sharedInstance.noteList.add(note);
	                    //添加至任务队列 异步加载 此处页面并未显示 如果直接调用划线将不准确
	                    setTimeout(function () {
	                        _NoteManager.NoteManager.sharedInstance._applyInlineStyle(note, false);
	                    }, 0);
	                })();
	            }
	        }
	    }

	    _Core.Core.postMessageToMobile('repaintNoteCompleted', '');
	}

	//更新笔记
	function updateNote(dataId, comment) {
	    _NoteManager.NoteManager.sharedInstance.noteList.update(dataId, comment);
	    var note = _NoteManager.NoteManager.sharedInstance.noteList.getNote(dataId);
	    _NoteManager.NoteManager.sharedInstance.clearInlineStyle(dataId);
	    _NoteManager.NoteManager.sharedInstance._applyInlineStyle(note, false);

	    _Core.Core.postMessageToMobile('updateNote', true);
	}

	/**
	 *阅读界面背景颜色切换
	 *
	 *param color = #fffff 或 0xffffff
	 */
	//let bgColorEffect = new FreeFallingEffect();
	var bgColorEffect = null;
	function colorEffect() {
	    if (!bgColorEffect) {
	        bgColorEffect = new _DotMatrixEffect.DotMatrixEffect();
	    }
	    return bgColorEffect;
	}
	function configBackgroundColor(color) {
	    var needAnimation = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];

	    colorEffect().changeToColor(color, needAnimation);
	}

	function bgBringToFront() {
	    colorEffect().bringToFront();
	}

	function bgBackToFloor() {
	    colorEffect().backToFloor();
	}

/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.NoteObject = undefined;

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _NoteManager = __webpack_require__(2);

	var _DomUtil = __webpack_require__(32);

	var _Core = __webpack_require__(31);

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var NoteObject = exports.NoteObject = function () {
	    function NoteObject(parentEle, startContainerEle, endContainerEle, startOffset, endOffset, groupId, comment, text) {
	        _classCallCheck(this, NoteObject);

	        this.parent = parentEle;
	        this.startContainer = startContainerEle;
	        this.endContainer = endContainerEle;
	        this.startOffset = startOffset;
	        this.endOffset = endOffset;
	        this.groupId = groupId;
	        this.comment = comment;
	        this.text = text;
	    }

	    _createClass(NoteObject, [{
	        key: 'getJSON',
	        value: function getJSON() {
	            var view = _NoteManager.NoteManager.sharedInstance.view;
	            var doc = _NoteManager.NoteManager.sharedInstance.document;
	            var position_parent = _DomUtil.DomUtil.getPosition(doc.body, this.parent);
	            var position_start = _DomUtil.DomUtil.getPosition(this.parent, this.startContainer);
	            var position_end = _DomUtil.DomUtil.getPosition(this.parent, this.endContainer);
	            /**
	             * 返回data含义
	             '{"dataId":"9bc1b40b-eafa-44f1-8e11-86e2751b757f",'此条笔记的id
	            '"index":2,' 此条笔记所在的html对应页面的index
	            '"startContainer":[6,9],' 此条笔记对应的开始节点 从 body元素找起 第一层的第六个元素，第二层的第9个元素
	            '"endContainer":[8,1],' 此条笔记对应的开始节点 从 body元素找起 第一层的第六个元素，第二层的第9个元素
	            '"startOffset":81,"endOffset":144,' 在起始节点中的文字偏移量
	            '"parent":[2],' 起始节点与中止节点公共父元素（直接父元素）位置信息
	            '"time":1445755306203,'+ note创建时间
	            '"tag":"comment",'+ 此条笔记属于评论（还有 underline 与 copy 对应不同的操作）
	            //选中的纯文本信息
	            '"text":"text",'+
	            //评论内容(tag为comment时才有)
	            '"comment":"comment"}';
	             */
	            var data = {
	                'dataId': this.groupId,
	                'index': view.book.currentChapter.spinePos,
	                'startContainer': position_start,
	                'endContainer': position_end,
	                'startOffset': this.startOffset,
	                'endOffset': this.endOffset,
	                'parent': position_parent,
	                'time': new Date().getTime(),
	                'text': this.text,
	                'comment': this.comment,
	                'chapterName': view.chapterName.innerText
	            };
	            return data;
	        }
	    }], [{
	        key: 'createByJSON',
	        value: function createByJSON(json) {
	            var doc = _NoteManager.NoteManager.sharedInstance.view.iframeObj.bodyEl;
	            var parentEle = _DomUtil.DomUtil.findNode(doc, json.parent);
	            var startContainer = _DomUtil.DomUtil.findNode(parentEle, json.startContainer);
	            var endContainer = _DomUtil.DomUtil.findNode(parentEle, json.endContainer);

	            return new NoteObject(parentEle, startContainer, endContainer, json.startOffset, json.endOffset, json.dataId, json.comment, json.text);
	        }
	    }, {
	        key: 'createByRange',
	        value: function createByRange(range, comment) {
	            var text = range.toString();
	            if (text.length == 0) {
	                return null;
	            }
	            var parentEle = range.commonAncestorContainer;

	            return new NoteObject(parentEle, range.startContainer, range.endContainer, range.startOffset, range.endOffset, _Core.Core.uuid(), comment, text);
	        }
	    }]);

	    return NoteObject;
	}();

/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.DotMatrixEffect = undefined;

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _IColorChange2 = __webpack_require__(43);

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *点阵效果1
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *1，当前色做为1像素的点间隔分布在屏幕上
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *2，一步步放大这些点直至填满屏幕
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */


	var GREN = __webpack_require__(5);

	var DotMatrixEffect = exports.DotMatrixEffect = function (_IColorChange) {
	    _inherits(DotMatrixEffect, _IColorChange);

	    function DotMatrixEffect() {
	        _classCallCheck(this, DotMatrixEffect);

	        var defaultColor = '#fafafa';

	        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(DotMatrixEffect).call(this, defaultColor));

	        _this.renderer = new GREN.WebGLRenderer();
	        _this.renderer.setStyle(window.innerWidth, window.innerHeight, 'position:fixed; z-index:-10000; left:0px;' + ' top:0px;-webkit-tap-highlight-color:rgba(0, 0, 0, 0);');
	        document.body.appendChild(_this.renderer.canvas);

	        _this.gl = _this.renderer.gl;

	        if (_this.renderer.isWebGLSuported) {
	            _this.prg = null;

	            _this.vetexBuffer = null;
	            _this.indexBuffer = null;

	            _this.mvMatrix = GREN.Matrix4.identity();
	            GREN.Matrix4.scale(_this.mvMatrix, [_this.renderer.canvasWidth, _this.renderer.canvasHeight, 1]);
	            //this.pMatrix = Matrix4.orthogonal(-this.renderer.canvasWidth, this.renderer.canvasWidth, -this.renderer.canvasHeight, this.renderer.canvasHeight, -5000.0, 5000.0);
	            _this.pMatrix = GREN.Matrix4.orthogonal(0, _this.renderer.canvasWidth, _this.renderer.canvasHeight, 0, -5000.0, 5000.0);

	            _this.initProgram();
	            _this.createIndexBuffer();
	            _this.glConfig();
	        } else {
	            _this.currentColor = defaultColor;
	            _this.drawCanvas2d();
	        }
	        return _this;
	    }

	    _createClass(DotMatrixEffect, [{
	        key: 'glConfig',
	        value: function glConfig() {
	            this.reset();

	            this.gl.uniformMatrix4fv(this.prg.uMVMatrix, false, this.mvMatrix);
	            this.gl.uniformMatrix4fv(this.prg.uPMatrix, false, this.pMatrix);
	            this.gl.uniform1f(this.prg.frameIndex, this.frameIndex);
	            this.gl.uniform1f(this.prg.screenWidth, this.renderer.canvasWidth);
	            this.gl.uniform1f(this.prg.screenHeight, this.renderer.canvasHeight);
	            var blockWidth = this.renderer.canvasWidth / Math.round(this.renderer.canvasWidth / (25 * window.devicePixelRatio));
	            this.frameCount = blockWidth;
	            this.gl.uniform1f(this.prg.blockWidth, blockWidth);
	            this.gl.uniform1f(this.prg.blockCenter, blockWidth / 2.0);
	        }
	    }, {
	        key: 'reset',
	        value: function reset() {
	            this.frameIndex = 0.0;
	            this.speed = 1.0;
	            this.accelerate = 0.2;

	            this.gl.uniform4fv(this.prg.backColor, this.lastColor);
	            this.gl.uniform4fv(this.prg.noiseColor, this.currentColor);

	            this.drawStaticColor();
	        }

	        //在窗口的最上层显示

	    }, {
	        key: 'bringToFront',
	        value: function bringToFront() {
	            this.renderer.canvas.style.zIndex = 10000;
	        }
	    }, {
	        key: 'backToFloor',
	        value: function backToFloor() {
	            this.renderer.canvas.style.zIndex = -10000;
	        }
	    }, {
	        key: 'drawCanvas2d',
	        value: function drawCanvas2d() {
	            this.gl.fillStyle = this.currentColor;
	            this.gl.fillRect(0, 0, this.renderer.canvasWidth, this.renderer.canvasHeight);
	        }
	    }, {
	        key: 'getVetexShader',
	        value: function getVetexShader() {
	            return '\n    attribute vec3 aVertexPosition;\n    uniform mat4 uMVMatrix;\n    uniform mat4 uPMatrix;\n    varying vec3 vPointCoord;\n    \n\n    void main(void) {\n      vPointCoord = aVertexPosition;\n      gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\n    }\n    ';
	        }
	    }, {
	        key: 'getFragmentShader',
	        value: function getFragmentShader() {
	            return '\n        #ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n            uniform vec4 backColor;\n            uniform vec4 noiseColor;\n\n            uniform float frameIndex;\n\n            uniform float screenWidth;\n            uniform float screenHeight;\n\n            varying vec3 vPointCoord;\n\n            uniform float blockWidth;\n            uniform float blockCenter;\n\n            void main(void) {\n                vec2 newPoint = vec2(dot(vPointCoord.x, screenWidth), dot(vPointCoord.y, screenHeight)) ;\n                vec2 blockCoord = mod(newPoint, blockWidth);\n                vec2 modValue = abs(vec2(blockCoord.x-blockCenter, blockCoord.y-blockCenter));\n\n                /**\n                设blockWidth 为块的宽\n                blockCenter 为块的中心点\n                离中心点越远,则颜色越混合\n                */\n                 float frame = frameIndex/2.0;\n                 if (step(frame, modValue.x) == 1.0 && step(frame, modValue.y) == 1.0) {\n                    float rate = frame/2.0/blockCenter;\n                    //离中心点越近值越小\n                    //float rateX = abs(modValue.x-blockCenter) / blockCenter;\n                    //float rateY = abs(modValue.y-blockCenter)/ blockCenter;\n                    gl_FragColor = mix(backColor, noiseColor, rate);\n                } else {\n                    gl_FragColor = noiseColor;\n                }\n            }\n       ';
	        }
	    }, {
	        key: 'initProgram',
	        value: function initProgram() {
	            this.prg = this.gl.makeProgram(this.getVetexShader(), this.getFragmentShader());
	            if (this.prg === null) {
	                this.renderer.setCanvas2d();
	            } else {
	                this.prg.setAttribLocations(['aVertexPosition']);
	                this.prg.setUniformLocations(['backColor', 'noiseColor', 'frameIndex', 'screenHeight', 'screenWidth', 'blockWidth', 'blockCenter', 'uPMatrix', 'uMVMatrix']);
	            }
	        }
	    }, {
	        key: 'createIndexBuffer',
	        value: function createIndexBuffer() {
	            //以左下角为原点的写法
	            var vertices = [0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0];
	            this.indices = [0, 1, 2, 0, 2, 3];

	            this.vetexBuffer = this.gl.createArrayBufferWithData(vertices);
	            this.indexBuffer = this.gl.createElementBufferWithData(this.indices);
	        }
	    }, {
	        key: 'drawStaticColor',
	        value: function drawStaticColor() {
	            this.gl.clearColor(this.lastColor[0], this.lastColor[1], this.lastColor[2], 1.0);
	            this.gl.disable(this.gl.DEPTH_TEST);
	            this.gl.clear(this.gl.COLOR_BUFFER_BIT);
	            this.gl.viewport(0, 0, this.renderer.canvasWidth, this.renderer.canvasHeight);
	        }
	    }, {
	        key: 'changeToColor',
	        value: function changeToColor(color) {
	            var needAnimation = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];

	            if (!this.renderer.isWebGLSuported) {
	                this.currentColor = color;
	                this.drawCanvas2d();
	            } else {
	                _get(Object.getPrototypeOf(DotMatrixEffect.prototype), 'changeToColor', this).call(this, color, needAnimation);
	                if (!needAnimation) {
	                    this.reset();
	                }
	            }
	        }
	    }, {
	        key: 'startAnimating',
	        value: function startAnimating() {
	            if (this.renderer.isWebGLSuported) {
	                _get(Object.getPrototypeOf(DotMatrixEffect.prototype), 'startAnimating', this).call(this);
	            }
	            this.reset();
	        }
	    }, {
	        key: 'enterFrame',
	        value: function enterFrame() {
	            this.updateSpeed();

	            this.gl.uniform1f(this.prg.frameIndex, this.frameIndex);
	            this.update();

	            if (this.frameIndex >= this.frameCount) {} else {
	                _get(Object.getPrototypeOf(DotMatrixEffect.prototype), 'enterFrame', this).call(this);
	            }
	        }
	    }, {
	        key: 'updateSpeed',
	        value: function updateSpeed() {
	            this.frameIndex += this.speed;
	            if (this.frameIndex > this.frameCount) {
	                this.frameIndex = this.frameCount;
	            }
	            this.speed += this.accelerate;
	        }
	    }, {
	        key: 'update',
	        value: function update() {
	            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vetexBuffer);
	            this.gl.vertexAttribPointer(this.prg.aVertexPosition, 3, this.gl.FLOAT, false, 0, 0);
	            this.gl.enableVertexAttribArray(this.prg.aVertexPosition);

	            this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);

	            this.gl.drawElements(this.gl.TRIANGLES, this.indices.length, this.gl.UNSIGNED_SHORT, 0);
	        }
	    }]);

	    return DotMatrixEffect;
	}(_IColorChange2.IColorChange2);

/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.IColorChange2 = undefined;

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _Color = __webpack_require__(44);

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Created by grenlight on 16/1/20.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */


	var GREN = __webpack_require__(5);

	var IColorChange2 = exports.IColorChange2 = function (_GREN$IAnimation) {
	    _inherits(IColorChange2, _GREN$IAnimation);

	    function IColorChange2() {
	        var hexColor = arguments.length <= 0 || arguments[0] === undefined ? '#fafafa' : arguments[0];

	        _classCallCheck(this, IColorChange2);

	        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(IColorChange2).call(this));

	        var rgb = _Color.Color.hex2rgb(hexColor);
	        _this.lastColor = [rgb[0], rgb[1], rgb[2], 1];
	        _this.currentColor = _this.lastColor;
	        return _this;
	    }

	    _createClass(IColorChange2, [{
	        key: 'drawStaticColor',
	        value: function drawStaticColor() {}
	    }, {
	        key: 'changeToColor',
	        value: function changeToColor(color) {
	            var needAnimation = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];

	            var rgb = _Color.Color.hex2rgb(color);
	            var hex = rgb.concat([1]);

	            if (needAnimation === true) {
	                this.stopAnimating();

	                this.lastColor = this.currentColor;
	                this.currentColor = hex;
	                this.startAnimating();
	            } else {
	                this.currentColor = hex;
	                this.lastColor = this.currentColor;
	                this.stopAnimating();
	            }
	        }
	    }]);

	    return IColorChange2;
	}(GREN.IAnimation);

/***/ },
/* 44 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var Color = exports.Color = function () {
	  function Color() {
	    _classCallCheck(this, Color);
	  }

	  _createClass(Color, null, [{
	    key: 'hex2rgb',
	    value: function hex2rgb(hex) {
	      if (hex.substr(0, 1) === '#') {
	        hex = '0x' + hex.substr(1, hex.length - 1);
	      }
	      var out = [];
	      out[0] = (hex >> 16 & 0xFF) / 255;
	      out[1] = (hex >> 8 & 0xFF) / 255;
	      out[2] = (hex & 0xFF) / 255;

	      return out;
	    }
	  }, {
	    key: 'str2hex',
	    value: function str2hex(color) {
	      var hex = void 0;
	      if (color.substr(0, 1) === '#') {
	        hex = '0x' + color.substr(1, color.length - 1);
	      } else {
	        hex = color;
	      }
	      return hex;
	    }
	  }]);

	  return Color;
	}();

/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.Replace = undefined;

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	/**
	 * 替换页面内的所有的hrefs
	 * @param callback
	 * @param renderer
	 */


	var _Core = __webpack_require__(31);

	var _config = __webpack_require__(7);

	var Config = _interopRequireWildcard(_config);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var Replace = exports.Replace = function () {
	    function Replace() {
	        _classCallCheck(this, Replace);
	    }

	    _createClass(Replace, null, [{
	        key: 'Hrefs',
	        value: function Hrefs(renderer, book) {
	            var replacements = function replacements(link, done) {
	                var href = link.getAttribute("href"),
	                    isRelative = href.search("://"),
	                    directory,
	                    relative;
	                if (isRelative != -1) {
	                    link.setAttribute("target", "_blank");
	                } else {
	                    link.setAttribute("href", "javascript:void(0)");
	                    var uri = _Core.Core.uri(book.book.currentChapter.absolute);
	                    // var uri = Core.uri(renderer.iframeObj.iframe.contentWindow.location.href);
	                    directory = uri.directory;

	                    if (directory) {
	                        relative = _Core.Core.resolveUrl(directory, href);
	                    } else {
	                        relative = href;
	                    }
	                    var touchStartX, touchEndX;
	                    link.addEventListener(Config.TOUCH_START, function (event) {
	                        touchStartX = event.clientX || (event.touches && event.touches.length > 0 ? event.touches[0].clientX : event.changedTouches[0].clientX);
	                    }, false);
	                    link.addEventListener(Config.TOUCH_END, function (event) {
	                        touchEndX = event.clientX || (event.touches && event.touches.length > 0 ? event.touches[0].clientX : event.changedTouches[0].clientX);
	                        if (touchEndX == touchStartX) {
	                            event.stopPropagation();
	                            book.gotoHref(relative);
	                            return false;
	                        }
	                    }, false);
	                }

	                done();
	            };

	            renderer.replace("a[href]", replacements);
	        }
	    }]);

	    return Replace;
	}();

/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.Explain = undefined;

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Created by Robin on 2016/7/14.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */


	var _config = __webpack_require__(7);

	var config = _interopRequireWildcard(_config);

	var _NoteManager = __webpack_require__(2);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	//import {BubbleView} from '../components/BubbleView.js'

	var Explain = exports.Explain = function () {
	    function Explain() {
	        _classCallCheck(this, Explain);
	    }

	    _createClass(Explain, null, [{
	        key: 'Abbrs',
	        value: function Abbrs(renderer) {
	            //替换abbr标签
	            var processAbbrs = function processAbbrs(abbr, done) {
	                var title = abbr.getAttribute("title");

	                abbr.removeAttribute("title");
	                abbr.setAttribute("data-title", title);
	                var imgEl = document.createElement("img");
	                imgEl.src = renderer.book.explainPath;
	                abbr.appendChild(imgEl);

	                Explain.AddEventListener(abbr);
	                done();
	            };
	            renderer.replace('abbr', processAbbrs);
	        }
	    }, {
	        key: 'AddEventListener',
	        value: function AddEventListener(abbr) {
	            abbr.querySelector('img').addEventListener(config.TOUCH_START, function (event) {
	                event.stopPropagation();
	                var rect = abbr.querySelector('img').getBoundingClientRect();
	                var offsetY = _NoteManager.NoteManager.sharedInstance.view.book.padding.top;
	                //var position = {
	                //    left: rect.left + rect.width / 2,
	                //    top: rect.top + offsetY,
	                //    height:rect.height
	                //}

	                //BubbleView.sharedInstance.ifNeedsDisplay(abbr.dataset.title, position);
	                var position = new GREN.Vector2(rect.left + 8, rect.top + 8 + offsetY);
	                GLBubbleView.sharedInstance.ifNeedsDisplay(abbr.dataset.title, position);
	            }, false);
	        }
	    }]);

	    return Explain;
	}();

/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.Iframe = undefined;

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Created by wangwy on 15-9-24.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */


	var _Core = __webpack_require__(31);

	var _Layout = __webpack_require__(39);

	var _Hooks = __webpack_require__(33);

	var _DecryptedCaches = __webpack_require__(48);

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var Iframe = exports.Iframe = function () {
	    function Iframe(book) {
	        _classCallCheck(this, Iframe);

	        this.book = book;
	        this.document = null;
	        this.window = null;
	        this.docEl = null;
	        this.bodyEl = null;

	        this.leftPos = 0;
	        this.iframe = Iframe.createIframeElement();
	    }

	    _createClass(Iframe, [{
	        key: 'load',


	        /**
	         * 加载iframe内的页面
	         * @param url
	         */
	        value: function load(url, spineIndex) {
	            var needCache = arguments.length <= 2 || arguments[2] === undefined ? true : arguments[2];

	            var that = this;
	            return new Promise(function (resolve) {
	                that.iframe.onload = function () {
	                    that.onloadFunc();
	                    resolve();
	                };

	                if (that.book.isEncrypted) {
	                    _DecryptedCaches.DecryptedCaches.sharedInstance.getHTMLStr(url, spineIndex, that.book.decryptKey, function (decryptedText) {
	                        // srcdoc 可以用来加载 html string, iOS 8, Android 4.4 都支持, 但 ie, edge 不支持
	                        that.iframe.srcdoc = decryptedText;
	                    }, needCache);
	                } else {
	                    that.iframe.src = url;
	                }
	            });
	        }
	    }, {
	        key: 'onloadFunc',
	        value: function onloadFunc() {
	            this.document = this.iframe.contentDocument;
	            this.window = this.iframe.contentWindow;

	            this.docEl = this.document.documentElement;
	            this.bodyEl = this.document.body || this.document.querySelector("body");

	            if (this.bodyEl) {
	                this.addHeadTags();
	                this.bodyEl.setAttribute('style', _Layout.Layout.getBodyStyle(this.book));
	                this.docEl.setAttribute('style', _Layout.Layout.getColumnStyle(this.book));
	                _Hooks.Hooks.instance.triggerHooks(_Hooks.HooksKey.BEFORE_FORMAT, this.bodyEl, this.book.contentWidth, this.book.contentHeight);
	            }
	        }

	        /**
	         * 根据页码获取向左的偏移量
	         * @param pg
	         * @param time
	         */

	    }, {
	        key: 'page',
	        value: function page(pg, time) {
	            var leftPos = this.book.pageWidth * (1 - pg);
	            return this.setLeft(leftPos, time);
	        }
	    }, {
	        key: 'getLeft',


	        /**
	         * 根据页码计算出偏移量
	         * @param pg
	         */
	        value: function getLeft() {
	            var leftPos = this.book.pageWidth * (1 - this.book.currentChapter.chapterPos);
	            return leftPos;
	        }
	    }, {
	        key: 'setLeft',


	        /**
	         * 设置页面向左的偏移量与持续时间
	         * @param lefPos
	         * @param time
	         * @return {boolean} setAnimation success?
	         */
	        value: function setLeft(lefPos) {
	            var time = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];

	            var reg = /translate3d\((-?[0-9]*)[^\D]*/;
	            var result = reg.exec(this.docEl.style.webkitTransform);
	            var currentLeftPos = result[1];
	            if (Math.abs(lefPos - currentLeftPos) < 0.1) {
	                return false;
	            }
	            this.docEl.style.webkitTransition = '-webkit-transform ' + time + 'ms cubic-bezier(0.33, 0.66, 0.66, 1)';
	            this.docEl.style.webkitTransform = 'translate3d(' + lefPos + 'px, 0, 0)';
	            return true;
	        }
	    }, {
	        key: 'getPageNumberByElement',


	        /**
	         * 计算节点在第几页
	         * @param el
	         * @returns {number}
	         */
	        value: function getPageNumberByElement(el) {
	            if (el) {
	                var left, pg;
	                left = Math.abs(this.getLeft()) + el.getBoundingClientRect().left;
	                pg = Math.floor(left / this.book.pageWidth) + 1;
	                return pg;
	            }
	            return 1;
	        }
	    }, {
	        key: 'getPageNumberByElementID',
	        value: function getPageNumberByElementID(id) {
	            var el = this.document.getElementById(id);
	            return this.getPageNumberByElement(el);
	        }

	        /**
	         * head标签里添加新的标签
	         *
	         * appendChild 会导致页面重排,故,使用fragment来优化多次append为一次
	         */

	    }, {
	        key: 'addHeadTags',
	        value: function addHeadTags() {
	            var headTags = this.book.headTags;
	            if (headTags === null) {
	                return;
	            }
	            var headEl = this.document.head;
	            if (!headEl) {
	                return;
	            }
	            var fragment = this.document.createDocumentFragment();
	            var styleEl = this.document.createElement("style");
	            var cssContent = _Layout.Layout.getAbbrStyle();
	            cssContent += _Layout.Layout.paragraphStyle();
	            styleEl.type = "text/css";
	            if (styleEl.styleSheet) {
	                styleEl.styleSheet.cssText = cssContent;
	            } else {
	                styleEl.innerHTML = cssContent;
	            }
	            fragment.appendChild(styleEl);

	            headTags.forEach(function (headTag) {
	                for (var tag in headTag) {
	                    var attrs = headTag[tag];
	                    var tagEl = this.document.createElement(tag);
	                    for (var attr in attrs) {
	                        tagEl.setAttribute(attr, attrs[attr]);
	                    }
	                    fragment.appendChild(tagEl);
	                }
	            }, this);
	            headEl.appendChild(fragment);
	        }
	    }, {
	        key: 'getPageNumberByRect',


	        /**
	         * 计算RECT在第几页
	         * @param boundingClientRect
	         * @returns {number}
	         */
	        value: function getPageNumberByRect(boundingClientRect) {
	            var leftPos = this.book.pageWidth * (this.book.currentChapter.chapterPos - 1);
	            var left = leftPos + boundingClientRect.left;
	            var pg = Math.floor(left / this.book.pageWidth) + 1;
	            return pg;
	        }
	    }], [{
	        key: 'createIframeElement',
	        value: function createIframeElement() {
	            var elem = document.getElementById("iframe");
	            if (elem) {
	                return elem;
	            }
	            var iframe = document.createElement('iframe');
	            iframe.id = "iframe";
	            iframe.scrolling = "no";
	            iframe.seamless = "seamless";
	            iframe.setAttribute('style', 'border:none; height:100%; width:100%; -webkit-tap-highlight-color:rgba(0, 0, 0, 0);');

	            return iframe;
	        }
	    }]);

	    return Iframe;
	}();

/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * Created by grenlight on 16/6/3.
	 *
	 * 解密缓存
	 */

	var _Symbol = __webpack_require__(8);
	var singleton = _Symbol();
	var singletonEnforcer = _Symbol();

	var DecryptedCaches = exports.DecryptedCaches = function () {
	    function DecryptedCaches(enforcer) {
	        _classCallCheck(this, DecryptedCaches);

	        if (enforcer !== singletonEnforcer) {
	            throw 'DecryptedCaches 是单例类，调用方法：DecryptedCaches.sharedInstance';
	        } else {

	            /**
	             *  收到解密结果后的回调
	             *  回调需要与 spineIndex 匹配
	             */
	            this.completions = new Array(500);
	            this.caches = new Array(500);
	            this.needCaches = new Array(500);
	            this.cachedIndices = new Array();

	            /**
	             * 任务堆栈
	             * 优先级高的任务放到最顶上
	             * 每执行完一个任务便检查此堆栈并自动执行下一个
	             * 每添加一个
	             * @type {Array}
	             */
	            this.missions = new Array();
	            // 任务是否正在执行? 每添加一个检查它,保证任务在执行
	            this.isRunning = false;
	        }
	    }

	    _createClass(DecryptedCaches, [{
	        key: 'initWebWorker',
	        value: function initWebWorker(path) {
	            this.worker = new Worker(path);
	            this.worker.onmessage = this.handleMessage.bind(this);
	        }

	        // 清空缓存

	    }, {
	        key: 'cleanCache',
	        value: function cleanCache() {
	            var len = this.caches.length;
	            for (var i = 0; i < len; i++) {
	                this.caches[i] = null;
	                this.completions[i] = null;
	            }
	        }

	        // 解密 html

	    }, {
	        key: 'getHTMLStr',
	        value: function getHTMLStr(url, spineIndex, decryptKey) {
	            var completion = arguments.length <= 3 || arguments[3] === undefined ? null : arguments[3];
	            var needCache = arguments.length <= 4 || arguments[4] === undefined ? true : arguments[4];

	            var htmlStr = this.caches[spineIndex];
	            if (htmlStr) {
	                // console.log('cached:', spineIndex);
	                if (completion) {
	                    completion(htmlStr);
	                }
	                return;
	            }
	            // console.log('no cache!')
	            this.completions[spineIndex] = completion;
	            this.needCaches[spineIndex] = needCache;

	            this.worker.postMessage({ url: url, spineIndex: spineIndex, decryptKey: decryptKey });
	        }
	    }, {
	        key: 'handleMessage',
	        value: function handleMessage(event) {
	            if (event.data.error) {
	                throw new Error('无法加载文件, spine : ' + event.data.spineIndex);
	            }
	            var htmlStr = event.data.content;
	            var spineIndex = event.data.spineIndex;
	            if (this.needCaches[spineIndex] === true) {
	                // console.log('cached--', spineIndex);
	                this.cachedIndices.push(spineIndex);
	                this.caches[spineIndex] = htmlStr;
	            }
	            if (this.cachedIndices.length > 10) {
	                this.caches[this.cachedIndices.shift()] = null;
	                // console.log('--released', this.cachedIndices);
	            }
	            var completion = this.completions[spineIndex];

	            if (completion) {
	                completion(htmlStr);
	                this.completions[spineIndex] = null;
	            }
	        }
	    }], [{
	        key: 'sharedInstance',
	        get: function get() {
	            if (!this[singleton]) {
	                this[singleton] = new DecryptedCaches(singletonEnforcer);
	            }
	            return this[singleton];
	        }
	    }]);

	    return DecryptedCaches;
	}();

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.Epub = undefined;

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Created by grenlight on 16/1/13.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */


	var _Chapter = __webpack_require__(50);

	var _calculateTotalPage2 = __webpack_require__(53);

	var _Layout = __webpack_require__(39);

	var _Core = __webpack_require__(31);

	var _config = __webpack_require__(7);

	var CONST = _interopRequireWildcard(_config);

	var _DecryptedCaches = __webpack_require__(48);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var Epub = exports.Epub = function () {
	    function Epub(owner, options) {
	        _classCallCheck(this, Epub);

	        this.owner = owner;
	        // 是否是加密的 html
	        this.isEncrypted = false;
	        if (options.encryptedKey && options.encryptedKey.length > 3) {
	            this.isEncrypted = true;
	            this.decryptKey = options.encryptedKey;
	        }
	        this.explainPath = options.exlainPath;
	        var webworkerPath = '../bin/worker.js';
	        if (options.webworkerPath && options.webworkerPath.length > 8) {
	            webworkerPath = options.webworkerPath;
	        }
	        _DecryptedCaches.DecryptedCaches.sharedInstance.initWebWorker(webworkerPath);

	        //目录(章节)列表
	        this.spine = this.parseSpine(options.spine);
	        if (this.spine.length === 0) {
	            throw new Error('spine 不能为空');
	        }
	        this.path = options.path;
	        //当前目录(章节)
	        var spinePos = parseInt(options.offsetObj.spinePos) || 0;
	        if (spinePos >= this.spine.length) {
	            console.log('spinePos 的值越界了!');
	            spinePos = this.spine.length - 1;
	        }
	        this.currentChapter = this.spine[spinePos].becomeCurrentChapter();
	        this.currentPageNumber = 1;

	        this._disableUserInteractionCount = 0;
	        /**
	         *章节内文本偏移量,
	         *
	         * 更新时机:updateCurrentOffset()
	         * 1,page动画完成时,当为前章节内翻页时; = chapger.getPageInfoByOffset();
	         * 2,dispayChapter.then 第一页时 = 0; 非第一页时 = chapger.getCurrentPageMap();
	         *
	         * 使用时机
	         * dispayChapter().then() if (currentOffset >0) {
	         *    1,updatePageMap() ;
	         *    2, chapger.getPageInfoByOffset();
	         *    3,直接定位到章节内目标页, then.visible;
	         * }
	         */
	        this.currentOffset = parseInt(options.offsetObj.offset) || 0;

	        //整书的页码信息
	        this.parseChaptersInfo(options.chaptersNum);

	        //每章节在最终呈现前要插入的的标签
	        this.headTags = options.headTags || null;

	        //样式
	        this.padding = options.padding;
	        this.nightMode = 0; //默认为白天模式
	        this.fontSize = null;
	        this.fontFamily = null;
	        if (options.fontSize) {
	            this.fontSize = options.fontSize;
	        }
	        if (options.fontFamily) {
	            this.fontFamily = options.fontFamily;
	        }
	        if (options.nightMode) {
	            EPUBJS.BookInterface.configBackgroundColor("#252525", false);
	            this.nightMode = 1;
	        }
	        _Layout.Layout.calculateBodyStyle(this);
	    }

	    _createClass(Epub, [{
	        key: 'parseChaptersInfo',
	        value: function parseChaptersInfo(chaptersNum) {
	            this.chaptersNum = {};
	            if (chaptersNum !== null && chaptersNum['vertion'] === CONST.vertion) {
	                this.chaptersNum = chaptersNum;
	            }
	            if (typeof this.chaptersNum == "string") {
	                this.chaptersNum = JSON.parse(this.chaptersNum);
	            }
	            this._updateChapterInfoByTotalPage();
	        }

	        /**
	        * 是否可以响应用户交互
	        *
	        * 页面动画过程中,不响应用户手势
	        */

	    }, {
	        key: 'updateCurrentOffset',


	        /**
	         * 计算当前章节偏移量
	         * @param offset
	         */
	        value: function updateCurrentOffset() {
	            var offset = arguments.length <= 0 || arguments[0] === undefined ? -1 : arguments[0];

	            var pageInfo = void 0;
	            if (offset < 0) {
	                pageInfo = this.getCurrentPagePos();
	                if (pageInfo) {
	                    this.currentOffset = pageInfo.start;
	                }
	            } else {
	                this.currentOffset = offset;
	                pageInfo = this.currentChapter.getPageInfoByOffset(offset);
	                /**
	                 * 当章节偏移量为0时(章节第一页),需要更新一下当前页码
	                 * 因为可能是由拖动条触发的跳转,此时没有翻页动作,默认不会更新当前页码.
	                 */
	                this.updateCurrentPageNumber();
	            }
	            if (pageInfo) {
	                var info = { currentBookNum: this.currentPageNumber, spinePos: this.currentChapter.spinePos, startOffset: pageInfo.start, endOffset: pageInfo.end };
	                _Core.Core.postMessageToMobile("currentBookNum", info);
	                //console.log("currentBookNum:", info);
	            }
	        }

	        /**
	         * 设置每页的宽度与高度
	         * @param pageWidth
	         * @param pageHeight
	         */

	    }, {
	        key: 'setPageDimensions',
	        value: function setPageDimensions(screenSize) {
	            this.pageWidth = screenSize.width;
	            this.pageHeight = screenSize.height - (this.padding.top + this.padding.bottom);
	            //实际内容区域的高度与宽度
	            this.contentHeight = this.pageHeight;
	            this.contentWidth = this.pageWidth - this.padding.left - this.padding.right;
	        }
	    }, {
	        key: 'setFontFamily',
	        value: function setFontFamily(fontFamily) {
	            var chaptersNum = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

	            if (this.fontFamily !== fontFamily) {
	                this.fontFamily = fontFamily;
	                this.resetFontInfo(chaptersNum);
	            }
	        }
	    }, {
	        key: 'setFontSize',
	        value: function setFontSize(fontSize) {
	            var chaptersNum = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

	            if (this.fontSize !== fontSize) {
	                this.fontSize = fontSize;
	                this.resetFontInfo(chaptersNum);
	            }
	        }
	    }, {
	        key: 'resetFontInfo',
	        value: function resetFontInfo() {
	            var chaptersNum = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];

	            // 清理解密缓存数据
	            _DecryptedCaches.DecryptedCaches.sharedInstance.cleanCache();

	            this.resetChapterPageMap();
	            this.parseChaptersInfo(chaptersNum);
	            this.updateCurrentPageNumber();
	            _Layout.Layout.calculateBodyStyle(this);
	        }
	    }, {
	        key: 'resetChapterPageMap',
	        value: function resetChapterPageMap() {
	            this.spine.forEach(function (chapter) {
	                chapter.resetPageMap();
	            }, this);
	        }
	    }, {
	        key: 'spineIndexByURL',
	        value: function spineIndexByURL(url) {
	            for (var i = 0; i < this.spine.length; i++) {
	                var chapter = this.spine[i];
	                if (chapter.htmlFileName === url) {
	                    return chapter.spinePos;
	                }
	            }
	            return -1;
	        }
	    }, {
	        key: 'getChapterByIndex',
	        value: function getChapterByIndex(spinePos) {
	            if (spinePos < 0 || spinePos >= this.spine.length) {
	                spinePos = 0;
	            }
	            return this.spine[spinePos];
	        }

	        /**
	         * 解析spine
	         * @returns  {Array}
	         */

	    }, {
	        key: 'parseSpine',
	        value: function parseSpine(spine) {
	            var list = [];
	            spine.forEach(function (item) {
	                var chapter = new _Chapter.Chapter(this, item);
	                list.push(chapter);
	            }, this);
	            return list;
	        }

	        //计算整书页码

	    }, {
	        key: 'calculateTotalPage',
	        value: function calculateTotalPage() {
	            var _this = this;

	            var completion = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];

	            _Core.Core.postMessageToMobile("totalPageCalculateStart", {});
	            var startTime = new Date().getTime();
	            (0, _calculateTotalPage2.calculateTotalPage)(this, function () {
	                // 不计算总页码了,所以注掉了下面这行
	                // this._updateChapterInfoByTotalPage();
	                _this.updateCurrentPageNumber();
	                _this.chaptersNum['vertion'] = CONST.vertion;
	                _Core.Core.postMessageToMobile("chaptersNum", _this.chaptersNum);
	                var endTime = new Date().getTime();
	                console.log("总页码计算完成:", (endTime - startTime) / 1000);
	                if (completion) {
	                    completion();
	                }
	            });
	        }

	        //基于整书页码信息更新章节信息

	    }, {
	        key: '_updateChapterInfoByTotalPage',
	        value: function _updateChapterInfoByTotalPage() {
	            var pageOffset = 0;
	            for (var i = 0; i < this.spine.length; i++) {
	                var chapter = this.spine[i];
	                chapter.pageOffset = pageOffset;
	                chapter.pageCount = this.chaptersNum[chapter.spinePos];
	                pageOffset += chapter.pageCount;
	            }
	        }
	    }, {
	        key: 'isValidSpinePos',
	        value: function isValidSpinePos(spinePos) {
	            if (spinePos >= 0 && spinePos < this.spine.length) {
	                return true;
	            }
	            return false;
	        }
	        /**
	         * 更新当前章节
	         */

	    }, {
	        key: 'updateCurrentChapter',
	        value: function updateCurrentChapter(spinePos) {
	            if (spinePos >= 0 && spinePos < this.spine.length && !this.isCurrentChapter(spinePos)) {
	                this.currentChapter = this.spine[spinePos].becomeCurrentChapter();
	                this.currentOffset = 0;
	            }
	            return this.currentChapter;
	        }

	        //是否为当前章节

	    }, {
	        key: 'isCurrentChapter',
	        value: function isCurrentChapter(spinePos) {
	            if (this.currentChapter.spinePos === spinePos) {
	                return true;
	            }
	            return false;
	        }

	        /**
	         *  更新当前页码,
	         *
	         *   调用时机:
	         *   整书页码计算完成后 ;
	         *   翻页, 跳转后
	         */

	    }, {
	        key: 'updateCurrentPageNumber',
	        value: function updateCurrentPageNumber() {
	            this.currentPageNumber = this.currentChapter.pageOffset + this.currentChapter.chapterPos;
	            //更新页码信息
	            this.owner.showBookNum();
	        }
	    }, {
	        key: '_prePageNumber',
	        value: function _prePageNumber() {
	            this.currentPageNumber -= 1;
	            this.owner.showBookNum();
	        }
	    }, {
	        key: '_nextPageNumber',
	        value: function _nextPageNumber() {
	            this.currentPageNumber += 1;
	            this.owner.showBookNum();
	        }

	        //是否为最后一页

	    }, {
	        key: 'isLastPage',
	        value: function isLastPage() {
	            // 去掉了实现的总页码计算,只好通过如下逻辑来处理最后一页
	            console.log('isLastPage?', this.currentChapter.spinePos, this.currentChapter.pageCount);
	            if (this.spine.length - 1 === this.currentChapter.spinePos && this.currentPageNumber - this.currentChapter.pageOffset === this.currentChapter.pageCount) {
	                console.log('isLastPage:', this.currentChapter.pageCount);
	                _Core.Core.postMessageToMobile('isTheLastPage', {});
	                return true;
	            } else {
	                return false;
	            }
	        }

	        //是否为首页

	    }, {
	        key: 'isFirstPage',
	        value: function isFirstPage() {
	            if (this.currentPageNumber <= 1 && this.currentChapter.spinePos === 0) {
	                _Core.Core.postMessageToMobile('isTheFirstPage', {});
	                return true;
	            }
	            return false;
	        }

	        /**
	         * 进入下一章节
	         *
	         * @return {Chapter}  null 表示越界
	         */

	    }, {
	        key: 'intoNextChapter',
	        value: function intoNextChapter() {
	            var spinePos = this.currentChapter.spinePos + 1;
	            if (spinePos < this.spine.length) {
	                this.currentChapter = this.spine[spinePos].becomeCurrentChapter();
	                this.currentOffset = 0;
	                this._nextPageNumber();
	                return this.currentChapter;
	            }
	            return null;
	        }

	        /**
	         * 返回上一章节
	         *
	         * @return {Chapter}  null 表示越界
	         */

	    }, {
	        key: 'backToPreChapter',
	        value: function backToPreChapter() {
	            var spinePos = this.currentChapter.spinePos - 1;
	            if (spinePos >= 0) {
	                this.currentChapter = this.spine[spinePos].becomeCurrentChapter();
	                //表示切换章节后,需要定位到最后一页
	                this.currentOffset = -1;
	                this._prePageNumber();
	                return this.currentChapter;
	            }
	            return null;
	        }
	        /**
	         * 更新当前章节内的索引页
	         * @param pg 当前章节内的页码索引, 从 1 开始计数
	         * @return {boolean}     是否为当前章节
	         */

	    }, {
	        key: 'updateChapterPos',
	        value: function updateChapterPos(pg) {
	            // console.log("---updateChapterPos:" + pg, this.currentChapter.pageCount);
	            if (pg >= 1 && pg <= this.currentChapter.pageCount) {
	                this.currentChapter.chapterPos = pg;
	                this.updateCurrentPageNumber();
	                return true;
	            }
	            return false;
	        }

	        /**
	         * 是否为章节里的第一页
	         */

	    }, {
	        key: 'isChapterFirstPage',
	        value: function isChapterFirstPage() {
	            if (this.currentChapter.chapterPos === 1) {
	                return true;
	            }
	            return false;
	        }

	        /**
	         * 根据当前章节内偏移量获取ChapterPos
	         * @param offset
	         * @returns {number}
	         */

	    }, {
	        key: 'getChapterPosByOffset',
	        value: function getChapterPosByOffset(offset) {
	            var chapterPage = this.currentChapter.getPosByOffset(offset);
	            this.updateCurrentPageNumber();

	            return chapterPage;
	        }

	        /**
	         * 获取当前位置信息: 当前章节当前页的信息
	         */

	    }, {
	        key: 'getCurrentPagePos',
	        value: function getCurrentPagePos() {
	            return this.currentChapter.getCurrentPageMap();
	        }

	        //取得下一页

	    }, {
	        key: 'getNextPage',
	        value: function getNextPage() {
	            var nextPage = this.currentChapter.chapterPos + 1;
	            if (nextPage <= this.currentChapter.pageCount) {
	                this.currentChapter.chapterPos = nextPage;
	                this.updateCurrentPageNumber();
	            }
	            return nextPage;
	        }
	    }, {
	        key: 'getPrePage',
	        value: function getPrePage() {
	            var prePage = this.currentChapter.chapterPos - 1;
	            if (prePage > 0) {
	                this.currentChapter.chapterPos = prePage;
	                this.updateCurrentPageNumber();
	            }
	            return prePage;
	        }
	    }, {
	        key: 'enableUserInteraction',
	        get: function get() {
	            var isEnable = this._disableUserInteractionCount === 0 ? true : false;
	            return isEnable;
	        },
	        set: function set(isEnable) {
	            if (isEnable) {
	                this._disableUserInteractionCount -= 1;
	                if (this._disableUserInteractionCount < 0) {
	                    this._disableUserInteractionCount = 0;
	                }
	            } else {
	                this._disableUserInteractionCount += 1;
	            }
	        }
	    }]);

	    return Epub;
	}();

/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.Chapter = undefined;

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Created by wangwy on 15-10-12.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */

	var _calculatePageMap = __webpack_require__(51);

	var _PageInfo = __webpack_require__(52);

	var _Layout = __webpack_require__(39);

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var Chapter = exports.Chapter = function () {
	    function Chapter(owner, spineObject) {
	        _classCallCheck(this, Chapter);

	        this.owner = owner;
	        this.href = spineObject.href;
	        this.htmlFileName = this.href.split('/').pop();
	        this.absolute = spineObject.url;
	        this.id = spineObject.id;
	        this.spinePos = spineObject.index;
	        this.chapterNames = spineObject.chapterNames;
	        this.resetPageMap();
	    }

	    _createClass(Chapter, [{
	        key: 'resetPageMap',
	        value: function resetPageMap() {
	            //相对于整书页码的偏移量
	            this.pageOffset = 0;
	            this.pageCount = -1;
	            this.pageMap = [];
	            this.chapterNameMap = [];
	            //章节内当前页码,从1开始
	            this.chapterPos = 1;
	            //pagemap是否计算完完
	            this.isPageMapCalculated = false;
	        }

	        //成为当前章节

	    }, {
	        key: 'becomeCurrentChapter',
	        value: function becomeCurrentChapter() {
	            this.chapterPos = 1;
	            return this;
	        }

	        //更新章节总页码

	    }, {
	        key: 'updatePageCount',
	        value: function updatePageCount(iframeObj) {
	            this.pageCount = _Layout.Layout.calculatePages(iframeObj.docEl, this.owner);
	        }

	        /**
	         * 更新PageInfo列表
	         *
	         * 不能在此方法内重置this.pageCount, book.currrentOffset,
	         * 因为updatePageMap前,可能外部已经设置了需要的currrentOffset
	         * @param iframeObj
	         */

	    }, {
	        key: 'updatePageMap',
	        value: function updatePageMap(iframeObj) {
	            if (this.pageMap.length === 0) {
	                this.owner.enableUserInteraction = false;
	                this.pageMap = (0, _calculatePageMap.calculatePageMap)(this.owner, iframeObj);
	                /**
	                 * 由于总页码的计算可能不准确,取的是最大值会可能会导致某些章节最后一页是空页,
	                 *  故:在章节偏移量计算完成后再重置章节总页码;
	                 */
	                //console.log("___________"+this.pageCount, this.pageMap.length);
	                //console.log(this.pageMap);
	                if (this.pageMap.length < this.pageCount) {
	                    this.pageCount = this.pageMap.length;
	                }

	                this.isPageMapCalculated = true;
	                this.chapterNameMap = this.parseChapterNames(iframeObj);
	                this.owner.enableUserInteraction = true;
	            }
	            //this.owner.updateCurrentOffset();
	        }
	    }, {
	        key: 'getCurrentPageMap',
	        value: function getCurrentPageMap() {
	            if (this.isPageMapCalculated) {
	                if (this.chapterPos > this.pageCount) {
	                    this.chapterPos = this.pageCount;
	                }
	                return this.pageMap[this.chapterPos - 1];
	            }
	            return new _PageInfo.PageInfo();
	        }

	        /**
	         * 根据偏移量获取页码
	         * @returns {number}
	         */

	    }, {
	        key: 'getPosByOffset',
	        value: function getPosByOffset(offset) {
	            var pos = 1;
	            for (var i = 0; i < this.pageMap.length; i++) {
	                var map = this.pageMap[i];
	                if (offset >= map.start && offset <= map.end) {
	                    pos = i + 1;
	                    break;
	                }
	            }
	            this.chapterPos = pos;

	            return this.chapterPos;
	        }

	        /**
	         * 根据偏移量获取pageInfo
	         */

	    }, {
	        key: 'getPageInfoByOffset',
	        value: function getPageInfoByOffset(offset) {
	            for (var i = 0; i < this.pageMap.length; i++) {
	                var map = this.pageMap[i];
	                if (offset >= map.start && offset <= map.end) {
	                    return map;
	                }
	            }
	            //返回一个临时的pageInfo;
	            return new _PageInfo.PageInfo(offset, null, offset + 1);
	        }

	        /**
	         * 格式化标题
	         */

	    }, {
	        key: 'parseChapterNames',
	        value: function parseChapterNames(iframeObj) {
	            var nameMap = [];
	            //避免 epub 不规范导致的 chapterNames 不存在而引发异常
	            if (this.chapterNames === null || this.chapterNames === undefined || this.chapterNames.length === 0) {
	                return nameMap;
	            }
	            this.chapterNames.forEach(function (item, index) {
	                var chapterName = item.chapterName;
	                var path = item.path;
	                var paths = path.split("#");
	                if (paths.length === 1) {
	                    nameMap.push({ chapterName: chapterName, startPg: 1, endPg: null });
	                } else {
	                    var section = paths[1];
	                    var el = iframeObj.document.getElementById(section);
	                    if (el) {
	                        var pg = iframeObj.getPageNumberByElement(el);
	                        nameMap.push({ chapterName: chapterName, startPg: pg, endPg: null });
	                        if (index != 0) {
	                            nameMap[index - 1].endPg = pg - 1;
	                        }
	                    }
	                }
	            }, this);
	            nameMap[nameMap.length - 1].endPg = this.pageCount;
	            return nameMap;
	        }

	        /**
	         * 根据页码获取章节名称
	         * @param pg
	         */

	    }, {
	        key: 'getChapterNameBypg',
	        value: function getChapterNameBypg(pg) {
	            this.chapterNameMap.forEach(function (item) {
	                if (pg >= item.startPg && pg <= item.endPg) {
	                    return item.chapterName;
	                }
	            }, this);

	            return this.getChapterName();
	        }
	    }, {
	        key: 'getChapterName',
	        value: function getChapterName() {
	            if (this.chapterNames && this.chapterNames.length > 0) {
	                return this.chapterNames[0].chapterName;
	            } else {
	                return "";
	            }
	        }
	    }]);

	    return Chapter;
	}();

/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.calculatePageMap = calculatePageMap;

	var _Hooks = __webpack_require__(33);

	var _Core = __webpack_require__(31);

	var _PageInfo = __webpack_require__(52);

	function calculatePageMap(book, iframeObj) {
	    'use strict';

	    var root = iframeObj.bodyEl;
	    var pageWidth = book.pageWidth;
	    var pageOffset = iframeObj.getLeft() * -1;
	    var pageList = [];
	    var currentCharOffset = 0;
	    var currentPageIndex = 0;

	    function check(node) {
	        'use strict';
	        //不同的浏览器大小写不一样,真他妈的坑人
	        // img, audio, video, canvas , 是不能忽略的节点
	        //svg的nodeName = 'image',

	        var nodeName = node.nodeName.toLowerCase();
	        if (nodeName === 'img' || nodeName === 'video' || nodeName === 'audio' || nodeName === 'image' || nodeName === 'svg' || nodeName === 'canvas') {
	            processingNode(node, false);
	        } else if (node.nodeType === Node.TEXT_NODE) {
	            if (node.textContent.trim().length > 0) {
	                processingNode(node, true);
	            }
	        } else if (node.childNodes.length > 0) {
	            var children = Array.prototype.slice.call(node.childNodes);
	            children.forEach(function (child) {
	                check(child);
	            });
	        }
	    }

	    /**
	     * 处理节点
	     * @param node
	     */

	    var lastPageInfo = void 0;
	    function processingNode(node) {
	        'use strict';
	        //是否为有效节点

	        var isTextNode = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];
	        var range = document.createRange();
	        range.selectNodeContents(node);
	        var rect = range.getBoundingClientRect();
	        //无效range,比如: canvas内的替换字符
	        if (!isTextNode && (!rect || rect.width === 0 || rect.height === 0)) {
	            return;
	        }

	        /**
	         * 在单页内的
	         *
	         * 图片,音视频等都是算在单页内的,且计一个字符
	         */
	        if (!isTextNode || rect.right - rect.left < pageWidth) {
	            var pageIndex = Math.floor((rect.left + pageOffset) / pageWidth);

	            //页面的第一段文本
	            if (pageIndex === currentPageIndex) {
	                if (!pageList[currentPageIndex]) {
	                    lastPageInfo = new _PageInfo.PageInfo(currentCharOffset, range);
	                    if (!isTextNode) {
	                        lastPageInfo.jointSummaryByOtherNode(node);
	                    }
	                    pageList.push(lastPageInfo);
	                    currentPageIndex++;
	                }
	            } else {
	                if (lastPageInfo) {
	                    if (isTextNode) {
	                        lastPageInfo.jointSummaryByRange(range);
	                    } else {
	                        lastPageInfo.jointSummaryByOtherNode(node);
	                    }
	                }
	            }
	        } else {
	            //跨页的,按文字分割
	            var pages = splitCrossColumnTextNode(node, pageOffset, iframeObj.document, book.pageWidth, currentCharOffset);
	            lastPageInfo = pages[pages.length - 1];
	            pageList = pageList.concat(pages);
	            currentPageIndex += pages.length;
	        }
	        if (isTextNode) {
	            currentCharOffset += node.textContent.length - 1;
	        } else {
	            currentCharOffset += 1;
	        }
	    };
	    //sprint(root, check);
	    check(root);
	    root = null;

	    //更新每一个页面的 end
	    var pageCount = pageList.length;
	    if (pageCount === 0) {
	        var page = new _PageInfo.PageInfo(0, null, 1);
	        page.summary = '<tag />';
	        pageList.push(page);
	    } else {
	        var prePage = pageList[0];
	        for (var i = 1; i < pageCount; i++) {
	            var currentPage = pageList[i];
	            prePage.updateEnd(currentPage.start - 1);
	            prePage = currentPage;
	        }
	        prePage.updateEnd(currentCharOffset);
	    }

	    //console.log("pageMap总条数"+pageList.length);
	    //console.log(pageList[0]);
	    //if (pageList.length > 1) {
	    //    console.log(pageList[1]);
	    //}

	    return pageList;
	}

	/**
	 * 取出页面的所有element并循环
	 * @param root
	 * @param func
	 */
	/**
	 * Created by grenlight on 16/1/13.
	 */
	/**
	 * 计算每页的起始节点, 原名:mapPage
	 * @returns {Array}
	 */
	function sprint(root, func) {
	    var treeWalker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, null, false);
	    var node;
	    while (node = treeWalker.nextNode()) {
	        func(node);
	    }
	}

	/**
	 * 将跨页的textNode转换成pageInfo
	 *
	 * @param node
	 * @param limit
	 * @returns {*}
	 */

	function splitCrossColumnTextNode(node, pageOffset, doc, pageWidth, charOffset) {
	    'use strict';

	    var range = doc.createRange();
	    range.selectNode(node);
	    var rangeRect = range.getBoundingClientRect();
	    //节点起始位置在哪一页
	    var startPage = Math.ceil((rangeRect.left + pageOffset) / pageWidth);
	    var endPage = Math.ceil((rangeRect.right + pageOffset) / pageWidth);

	    var pages = [];
	    var rangeLeft = node.ownerDocument.createRange(),
	        rangeRight = node.ownerDocument.createRange();
	    var stopIndex = node.textContent.length - 1;
	    for (var i = startPage; i < endPage; i++) {
	        splitWord(0, stopIndex, pageWidth * i + pageOffset);
	    }

	    function splitWord(lower, uper, split) {
	        var middle = Math.floor((lower + uper) / 2);
	        rangeLeft.collapse(true);
	        rangeLeft.setStart(node, lower);
	        rangeLeft.setEnd(node, middle);

	        rangeRight.collapse(true);
	        rangeRight.setStart(node, middle + 1);
	        rangeRight.setEnd(node, stopIndex);

	        var leftRect = rangeLeft.getBoundingClientRect();
	        var rightRect = rangeRight.getBoundingClientRect();
	        if (middle === lower) {
	            var pageInfo = new _PageInfo.PageInfo(charOffset + uper, rangeRight.cloneRange());
	            pages.push(pageInfo);
	        } else {
	            if (leftRect.right <= split && rightRect.left >= split) {
	                var _pageInfo = new _PageInfo.PageInfo(charOffset + middle + 1, rangeRight.cloneRange());
	                pages.push(_pageInfo);
	            } else {
	                if (rightRect.left < split) {
	                    splitWord(middle, uper, split);
	                } else {
	                    splitWord(lower, middle, split);
	                }
	            }
	        }
	    }
	    return pages;
	}

/***/ },
/* 52 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * Created by grenlight on 16/1/14.
	 */

	var PageInfo = exports.PageInfo = function () {
	    function PageInfo() {
	        var start = arguments.length <= 0 || arguments[0] === undefined ? 0 : arguments[0];
	        var startRange = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	        var end = arguments.length <= 2 || arguments[2] === undefined ? 1 : arguments[2];

	        _classCallCheck(this, PageInfo);

	        this.start = start;
	        this.startRange = startRange;
	        //end 不能少, App端需要用来计算书签是否落在这一页
	        this.end = end;
	        /**
	         * 摘要生成规则:
	         * 1,跨标签取text;
	         * 2,遇到图片音视频标签,输出不带属性的当前标签做为文本,比如:<img />, 保证没有文本只有图片或音视频的页也有合适的摘要信息.
	         * 3,摘要内最多只包含一个图片音视频标签,表示有图片或音视频,多了没有意义.
	         */
	        this._isSummaryDone = false;
	        this._isSummaryContainOtherTag = false;
	        if (startRange) {
	            this.summary = startRange.startContainer.textContent.substr(startRange.startOffset, 100);
	            this._ifIsSummaryDone();
	        } else {
	            this.summary = '';
	        }
	    }

	    _createClass(PageInfo, [{
	        key: '_ifIsSummaryDone',
	        value: function _ifIsSummaryDone() {
	            if (this.summary.length >= 100) {
	                this._isSummaryDone = true;
	            }
	        }
	    }, {
	        key: 'jointSummaryByRange',
	        value: function jointSummaryByRange(range) {
	            if (this._isSummaryDone) return;
	            this.summary += range.startContainer.textContent.substr(range.startOffset, 100 - this.summary.length);
	            this._ifIsSummaryDone();
	        }

	        //除文本节点之外的其它节点

	    }, {
	        key: 'jointSummaryByOtherNode',
	        value: function jointSummaryByOtherNode(node) {
	            if (this._isSummaryDone || this._isSummaryContainOtherTag) return;
	            this.summary += '<' + node.nodeName.toLowerCase() + ' />';
	            this._isSummaryContainOtherTag = true;
	            this._ifIsSummaryDone();
	        }
	    }, {
	        key: 'updateEnd',
	        value: function updateEnd() {
	            var end = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];

	            this.end = end;
	        }
	    }]);

	    return PageInfo;
	}();

/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.calculateTotalPage = calculateTotalPage;

	var _Iframe = __webpack_require__(47);

	var _Layout = __webpack_require__(39);

	var _Hooks = __webpack_require__(33);

	var _Core = __webpack_require__(31);

	/**
	 * Created by grenlight on 16/1/13.
	 */
	function calculateTotalPage(book, completion) {
	    'use strict';

	    var chaptersNum = {},
	        chapterAllNum = 0;
	    for (var i = 0; i < book.spine.length; i++) {
	        chapterAllNum += 1;
	        chaptersNum[i] = 1;
	    }
	    chaptersNum["allNum"] = chapterAllNum;
	    book.chaptersNum = chaptersNum;
	    var pageElem = document.getElementById("bookPage");
	    pageElem.style.visibility = "hidden";
	    pageElem.style.display = "none";
	    // console.log(chaptersNum)
	    if (completion) {
	        completion();
	    }
	    return;

	    var iframeObj = new _Iframe.Iframe(book);
	    //iframeObj.iframe.setAttribute('style', 'visibility:hidden;display:none; width:0px;height:0px;');
	    iframeObj.iframe.style.display = 'none';
	    document.body.appendChild(iframeObj.iframe);

	    /**
	    *  遍历所有章节
	    *  此处不能使用 for 循环,因为onload是异步的
	    */
	    function getChapter(i) {
	        'use strict';

	        var chapter = book.spine[i];
	        iframeObj.load(chapter.absolute, chapter.spinePos, false).then(function () {
	            /**
	             *  Layout.calculatePages 占用了总页码计算时间的 70%
	             */
	            // console.log('url:', chapter.absolute);
	            var pageCount = _Layout.Layout.calculatePages(iframeObj.docEl, book);

	            chapter.pageCount = pageCount;
	            chapterAllNum += pageCount;
	            chaptersNum[i] = pageCount;
	            i++;

	            if (i === book.spine.length) {
	                chaptersNum["allNum"] = chapterAllNum;
	                document.body.removeChild(iframeObj.iframe);
	                iframeObj = null;

	                book.chaptersNum = chaptersNum;
	                if (completion) {
	                    completion();
	                }
	            } else {
	                setTimeout(function () {
	                    getChapter(i);
	                }, 0);
	            }
	        });
	    }
	    getChapter(0);
	}

/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.addEventListeners = addEventListeners;

	var _config = __webpack_require__(7);

	var Config = _interopRequireWildcard(_config);

	var _Core = __webpack_require__(31);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	/**
	 * Created by grenlight on 16/8/19.
	 */
	/**
	 * 为文档添加监听
	 */
	function addEventListeners() {
	    'use strict';

	    var _this = this;

	    var pageWidth = this.book.pageWidth;
	    var time = 400; //翻一页所持续的时间为500ms;
	    var Threshold = pageWidth / 4; //翻页移动的阈值，没超过这个阈值将停留在当前页面
	    var startX, endX, startTime;
	    var isLongTouch = false;
	    //用来禁止快速翻页行为
	    var needCancel = false;

	    var reader = this;
	    var touchStartHandler = function touchStartHandler(event) {
	        //此处不能阻止系统默认事件:文本选择等
	        event.stopPropagation();
	        if (!_this.book.enableUserInteraction) {
	            needCancel = true;
	            return;
	        }
	        reader.renderer.unHighlight();
	        isLongTouch = false;
	        needCancel = false;
	        startX = _this.getTouchPoint(event).x;
	        startTime = new Date();
	    };
	    var touchMoveHandler = function touchMoveHandler(event) {
	        if (!startTime || needCancel || isLongTouch) {
	            // console.log("moveHandler", startTime,  needCancel, isLongTouch)
	            return;
	        }

	        endX = _this.getTouchPoint(event).x;
	        var deltaX = endX - startX;
	        var timeInterval = new Date().getTime() - startTime.getTime();

	        if (timeInterval > 50 && Math.abs(deltaX) < 3) {
	            isLongTouch = true;
	        } else {
	            event.stopPropagation();
	            var pageOffsetX = reader.iframeObj.getLeft() + deltaX;
	            reader.iframeObj.setLeft(pageOffsetX);
	        }
	    };

	    function touchEndHandler(event) {
	        var timeInterval = new Date().getTime() - startTime.getTime();
	        startTime = null;
	        if (needCancel) {
	            return;
	        }
	        //此处用于避免touchMove独自响应
	        needCancel = true;

	        if (isLongTouch) {
	            reader.renderer.currentPage(100);
	            return;
	        }
	        //不能阻止了系统的事件,浏览器上下文菜单的消显需要它
	        event.stopPropagation();

	        var touchPoint = reader.getTouchPoint(event);
	        var deltaX = touchPoint.x - startX,
	            absDeltaX = Math.abs(deltaX);

	        if (timeInterval < 300 || absDeltaX > 20) {
	            var durTime = time * ((pageWidth - absDeltaX) / pageWidth);
	            var isTap = timeInterval < 150 && absDeltaX < 5;

	            /**
	             * 前后翻页的条件;
	             *
	             * 点击坐标落在屏幕两边
	             * 速划的距离大于20;
	             * 常速划动的距离大于Threshold
	             */
	            if (isTap) {
	                if (touchPoint.x > pageWidth * 0.66) {
	                    reader.nextPage(durTime);
	                } else if (touchPoint.x < pageWidth * 0.33) {
	                    reader.prevPage(durTime);
	                } else {
	                    _Core.Core.postMessageToMobile("screenClick", { screenX: touchPoint.x, screenY: touchPoint.y });
	                }
	            } else {
	                var isSweep = timeInterval < 200 && absDeltaX >= 20;
	                if (isSweep || absDeltaX >= Threshold) {
	                    if (deltaX < 0) {
	                        reader.nextPage(durTime / (isSweep ? 2 : 1));
	                    } else {
	                        reader.prevPage(durTime / (isSweep ? 2 : 1));
	                    }
	                } else {
	                    reader.renderer.currentPage(time - durTime);
	                }
	            }
	        } else {
	            reader.renderer.currentPage(100);
	        }
	    }
	    this.iframeObj.document.addEventListener(Config.TOUCH_START, touchStartHandler, false);
	    this.iframeObj.document.addEventListener(Config.TOUCH_MOVE, function (event) {
	        touchMoveHandler(event);
	    }, false);
	    this.iframeObj.document.addEventListener(Config.TOUCH_END, function (event) {
	        touchEndHandler(event);
	    }, false);
	}

/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.PageTurning = undefined;

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _config = __webpack_require__(7);

	var config = _interopRequireWildcard(_config);

	var _PageTurningShaders = __webpack_require__(56);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Created by grenlight on 16/5/19.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * 翻页动画
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

	// const GREN = require('GREN');

	var PageTurning = exports.PageTurning = function (_GREN$IAnimation) {
	    _inherits(PageTurning, _GREN$IAnimation);

	    function PageTurning() {
	        var width = arguments.length <= 0 || arguments[0] === undefined ? 300 : arguments[0];
	        var height = arguments.length <= 1 || arguments[1] === undefined ? 100 : arguments[1];
	        var img = arguments[2];

	        _classCallCheck(this, PageTurning);

	        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(PageTurning).call(this));

	        _this.renderer = new GREN.WebGLRenderer();
	        _this.renderer.setStyle(width, height, 'margin:0px; position:absolute; z-index:1;');
	        _this.gl = _this.renderer.gl;
	        _this.gl.enable(_this.gl.DEPTH_TEST);
	        //
	        _this.ext = _this.gl.getExtension("WEBGL_draw_buffers");

	        _this.domElement = _this.renderer.canvas;
	        if (_this.renderer.isWebGLSuported === false) {
	            return _possibleConstructorReturn(_this);
	        }
	        width = _this.renderer.canvasWidth;
	        height = _this.renderer.canvasHeight;

	        // 小视角透视效果小
	        var fovy = 10 / 180 * Math.PI;
	        _this.pMatrix = GREN.Matrix4.perspective(fovy, width / height, 0.1, 0.6);
	        _this.mvMatrix = new GREN.Matrix4();
	        var translateZ = 0.5;
	        GREN.Matrix4.translate(_this.mvMatrix, [0, 0, -translateZ]);
	        GREN.Matrix4.scale(_this.mvMatrix, [1.0 / height, 1.0 / height, 1.0 / height]);
	        var factor = Math.tan(fovy / 2) * translateZ;
	        GREN.Matrix4.scale(_this.mvMatrix, [factor * 2, factor * 2, factor * 2]);

	        // this.pMatrix = GREN.Matrix4.orthogonal(-width/2, width/2, -height/2, height/2, -1000.0, 5000.0);
	        // this.mvMatrix = new GREN.Matrix4();

	        _this.speed = [0, 0];
	        _this.autoAnimating = false;
	        _this.targetPosition = new GREN.Vector2();

	        // 是否为翻到下一页
	        _this.isRollToNext = true;
	        // 避免多指触摸的冲突, touch 期间只允许触发一次 start 事件
	        _this.isTouchMoving = false;

	        _this.radius = _this.renderer.canvasWidth / 8;
	        _this.halfCircle = Math.PI * _this.radius;
	        _this.rollLength = 0;

	        _this._initProgram();

	        var meshGap = 5;
	        _this.mesh = new GREN.PlaneGeometry(width, height, Math.floor(width / meshGap), Math.floor(height / meshGap));

	        _this._bindBuffers();

	        _this.glTexture = new GREN.GLTexture2D(_this.gl, img, function (texture) {
	            _this.gl.activeTexture(_this.gl.TEXTURE0);
	            _this.gl.bindTexture(_this.gl.TEXTURE_2D, texture);
	            _this.gl.uniform1i(_this.prg.texture, 0);

	            _this.enterFrame();
	        });
	        _this.touchListener();
	        return _this;
	    }

	    _createClass(PageTurning, [{
	        key: '_bindBuffers',
	        value: function _bindBuffers() {
	            if (!this.vertexBuffer) {
	                this.vertexBuffer = this.gl.createArrayBufferWithTypedArray(this.mesh.vertices);
	                this.textureBuffer = this.gl.createArrayBufferWithTypedArray(this.mesh.textureCoords);
	                this.indexBuffer = this.gl.createElementBufferWithTypedArray(this.mesh.indices);
	            }
	            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vertexBuffer);
	            this.gl.vertexAttribPointer(this.prg.vertexPosition, 3, this.gl.FLOAT, false, 0, 0);
	            this.gl.enableVertexAttribArray(this.prg.vertexPosition);

	            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.textureBuffer);
	            this.gl.vertexAttribPointer(this.prg.vTextureCoord, 2, this.gl.FLOAT, false, 0, 0);
	            this.gl.enableVertexAttribArray(this.prg.vTextureCoord);

	            this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
	        }
	    }, {
	        key: '_initProgram',
	        value: function _initProgram() {
	            this.prg = this.gl.makeProgram(_PageTurningShaders.vertexShader, _PageTurningShaders.fregmentShader);
	            this.prg.setAttribLocations(['vertexPosition', 'vTextureCoord']);
	            this.prg.setUniformLocations(['pMatrix', 'mvMatrix', 'radius', 'texture', 'color', 'screenSize', 'angle', 'np', 'n']);

	            this.gl.uniformMatrix4fv(this.prg.pMatrix, false, this.pMatrix);
	            this.gl.uniformMatrix4fv(this.prg.mvMatrix, false, this.mvMatrix);

	            this.gl.uniform1f(this.prg.radius, this.radius);
	            this.gl.uniform2fv(this.prg.screenSize, [this.renderer.canvasWidth, this.renderer.canvasHeight]);
	        }
	    }, {
	        key: 'touchListener',
	        value: function touchListener() {
	            var _this2 = this;

	            var moveHandler = function moveHandler(event) {
	                if (_this2.isAnimating || !_this2.needRolling) {
	                    return;
	                }
	                _this2.isTouchMoving = true;
	                _this2.currentPoint = _this2._getTouchPoint(event);
	                if (_this2.updateData(_this2.currentPoint)) {
	                    _this2.enterFrame();
	                }
	            };
	            var endHander = function endHander(event) {
	                _this2.isTouchMoving = false;
	                if (_this2.isAnimating || !_this2.needRolling) {
	                    return;
	                }
	                _this2.domElement.removeEventListener(config.TOUCH_MOVE, moveHandler);
	                _this2.autoAnimating = true;
	                _this2.frames = [];

	                var minWidth = _this2.renderer.canvasWidth / 3;
	                if (!_this2.isRollToNext) {
	                    _this2.rollLength = _this2.touchStart.x - _this2.currentPoint.x;
	                    minWidth *= 2.5;
	                }
	                var stepPixel = _this2.renderer.canvasWidth / 20;

	                if (_this2.rollLength < minWidth) {
	                    _this2.frames = _this2.frames.concat(_this2.generateFrameData(_this2.currentPoint, _this2.touchStart, _this2.rollLength / stepPixel));
	                } else {
	                    var targetPosition = new GREN.Vector2(-_this2.renderer.canvasWidth * 0.5, _this2.touchStart.y);
	                    var frameCount = Math.sqrt(Math.pow(targetPosition.x - _this2.touchStart.x, 2) + Math.pow(targetPosition.y - _this2.touchStart.y, 2)) / stepPixel;
	                    _this2.frames = _this2.frames.concat(_this2.generateFrameData(_this2.currentPoint, targetPosition, frameCount));

	                    var targetPosition2 = new GREN.Vector2(-_this2.renderer.canvasWidth * 1.5, _this2.touchStart.y);
	                    frameCount = Math.sqrt(Math.pow(targetPosition.x - targetPosition2.x, 2) + Math.pow(targetPosition.y - targetPosition2.y, 2)) / stepPixel;
	                    _this2.frames = _this2.frames.concat(_this2.generateFrameData(targetPosition, targetPosition2, frameCount));
	                }
	                _this2.startAnimating();
	            };

	            this.domElement.addEventListener(config.TOUCH_START, function (event) {
	                if (_this2.isAnimating || _this2.isTouchMoving) {
	                    return;
	                }

	                _this2.touchStart = _this2._getTouchPoint(event);
	                _this2.currentPoint = _this2.touchStart;
	                _this2.needRolling = false;

	                var offset = 40 * window.devicePixelRatio;
	                //  如果是往回翻页,则翻转 touchStart.x
	                if (_this2.touchStart.x >= _this2.renderer.centerX - offset) {
	                    _this2.isRollToNext = true;
	                    _this2.needRolling = true;
	                } else if (_this2.touchStart.x <= -(_this2.renderer.centerX - offset)) {
	                    _this2.isRollToNext = false;
	                    _this2.needRolling = true;
	                    _this2.touchStart.x *= -1;
	                }
	                if (_this2.needRolling) {
	                    _this2.domElement.addEventListener(config.TOUCH_MOVE, moveHandler);
	                }
	            });

	            this.domElement.addEventListener(config.TOUCH_END, endHander);
	            this.domElement.addEventListener(config.TOUCH_CANCEL, endHander);
	        }
	    }, {
	        key: 'generateFrameData',
	        value: function generateFrameData(currentPosition, targetPosition, frames) {
	            var deltaX = (targetPosition.x - currentPosition.x) / frames;
	            var deltaY = (targetPosition.y - currentPosition.y) / frames;
	            var frameData = [];
	            for (var i = 0; i < frames; i++) {
	                frameData.push(new GREN.Vector2(currentPosition.x + deltaX * i, currentPosition.y + deltaY * i));
	            }
	            return frameData;
	        }
	    }, {
	        key: 'updateData',
	        value: function updateData(touchPoint) {
	            var dx = this.touchStart.x - touchPoint.x;
	            var dy = this.touchStart.y - touchPoint.y;
	            //无效的卷动:垂直 && dx < 0
	            if (dx === 0 || !this.autoAnimating && dx < 0) {
	                return false;
	            }
	            var m = Math.sqrt(dx * dx + dy * dy);
	            var PI_2 = Math.PI / 2.0;

	            var a = Math.atan2(dy, dx);
	            var sinA = Math.sin(a);
	            //最大可卷起距离
	            var maxRoll = 0;
	            if (a === 0) {
	                maxRoll = m;
	            } else if (a < PI_2 && a > -PI_2) {
	                maxRoll = Math.abs(Math.cos(a) * this.renderer.canvasWidth);
	            }
	            this.rollLength = m;
	            if (m > this.halfCircle) {
	                this.rollLength = (m - this.halfCircle) / 2 + this.halfCircle;
	            }
	            if (this.rollLength > maxRoll) {
	                this.rollLength = maxRoll;
	            }
	            var np = [this.renderer.centerX - Math.abs(Math.cos(a) * this.rollLength), this.renderer.centerY * (a > 0 ? 1 : -1) - sinA * this.rollLength];
	            var n = [Math.cos(a), sinA];

	            this.gl.uniform1f(this.prg.angle, a);
	            this.gl.uniform2fv(this.prg.np, np);
	            this.gl.uniform2fv(this.prg.n, n);

	            this.angle = a;

	            return true;
	        }
	    }, {
	        key: 'nextStep',
	        value: function nextStep() {
	            var moveToTarget = this.frames.shift();
	            this.updateData(moveToTarget);

	            if (this.frames.length === 0) {
	                this.autoAnimating = false;
	                this.needRolling = false;
	                this.stopAnimating();
	            }
	        }
	    }, {
	        key: 'enterFrame',
	        value: function enterFrame() {
	            if (this.autoAnimating) {
	                _get(Object.getPrototypeOf(PageTurning.prototype), 'enterFrame', this).call(this);
	                this.nextStep();
	            }

	            this.gl.clearColor(0.0, 0.0, 0.0, 0.0);
	            this.gl.viewport(0, 0, this.renderer.canvasWidth, this.renderer.canvasHeight);
	            this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);

	            this.gl.drawElements(this.gl.TRIANGLES, this.mesh.indices.length, this.gl.UNSIGNED_SHORT, 0);
	        }
	    }, {
	        key: '_getTouchPoint',
	        value: function _getTouchPoint(event) {
	            var clientX = event.clientX || (event.touches && event.touches.length > 0 ? event.touches[0].clientX : event.changedTouches[0].clientX);
	            var clientY = event.clientY || (event.touches && event.touches.length > 0 ? event.touches[0].clientY : event.changedTouches[0].clientY);
	            clientX -= this.domElement.getBoundingClientRect().left;
	            return new GREN.Vector2(clientX * window.devicePixelRatio - this.renderer.centerX, this.renderer.centerY - clientY * window.devicePixelRatio);
	        }
	    }]);

	    return PageTurning;
	}(GREN.IAnimation);
	//测试时用


	window.PageTurning = PageTurning;

/***/ },
/* 56 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/**
	 * Created by grenlight on 16/6/16.
	 */

	var vertexShader = exports.vertexShader = "\nattribute vec3 vertexPosition;\nattribute vec2 vTextureCoord;\n\nuniform mat4 mvMatrix;\nuniform mat4 pMatrix;\n\nuniform float radius; // 开始卷动的半径\nuniform float angle;\nuniform vec2 np; \nuniform vec2 n;\n\nvarying vec2 texCoord;\nvarying vec3 verCoord;\n\nconst float PI = 3.1415926535;\nconst float PI_2 = 3.1415926535/2.0;\n\nvoid main(void) {\n    texCoord = vTextureCoord;\n    vec2 v = vertexPosition.xy-np;\n    float l = dot(v, n);\n    \n    vec4 pos;\n                 \n    if (l > 0.0) {\n        float halfCircle = PI * radius;\n        vec3 newPosition = vertexPosition.xyz;\n\n         // 卷起后与之前的位置差\n        float len;\n        if ( l <= halfCircle) {\n             // 切点到 halfCircle 之间的顶点计算卷起\n            float degress = (l / halfCircle) * PI - PI_2 ;\n            len = abs(l - cos(degress) * radius);\n            newPosition.z  = (radius + sin(degress) * radius) ;\n        } else {\n            len = l + (l - halfCircle);\n            newPosition.z  = radius * 2.0;\n        }\n        newPosition.y -= sin(angle) * len;\n        newPosition.x -= cos(angle) * len;\n            \n        verCoord = newPosition;\n        pos = pMatrix * mvMatrix * vec4(newPosition, 1.0);\n    } else {\n        verCoord = vertexPosition;\n        pos = pMatrix * mvMatrix * vec4(vertexPosition, 1.0);\n    }\n    pos.z = pos.z  * pos.w / 0.6;\n    gl_Position = pos;\n}\n";

	var fregmentShader = exports.fregmentShader = "\n#extension GL_EXT_draw_buffers : require \n\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\nuniform sampler2D texture;\nuniform vec2 screenSize; \nuniform float radius; \n\nvarying vec2 texCoord;\nvarying vec3 verCoord;\n\nconst float whiteWeight = 0.85;\nconst float texWeight = 0.10;\n\nvoid main(void) {\n    vec4 texColor = texture2D(texture, texCoord);\n    float diameter = radius*2.0;\n  \n    if (verCoord.z > 0.0) {\n        if (verCoord.z > radius) {\n            texColor *= texWeight;\n            vec4 newColor = vec4(whiteWeight + texColor.r , whiteWeight  + texColor.g, whiteWeight*0.98 + texColor.b, 1.0); \n                \n            if (verCoord.z < diameter) {\n                //模拟卷起片段的背面阴影, 卷起得越高,阴影越小\n                newColor.rgb *= (1.0 - 0.15 * ((diameter-verCoord.z) / radius));\n                 gl_FragColor = vec4(newColor.rgb, 1.0);\n            } else {\n                gl_FragColor = newColor; \n            } \n        } else {\n            //高效模拟卷起片段的内面阴影, 卷起得越高,阴影越大\n            texColor.rgb *= (1.0 - 0.2 * (verCoord.z / radius));\n            gl_FragColor = vec4(texColor.rgb, 1.0);\n        }        \n    } else {\n         gl_FragColor = texColor;\n    }\n}\n";

/***/ }
/******/ ]);