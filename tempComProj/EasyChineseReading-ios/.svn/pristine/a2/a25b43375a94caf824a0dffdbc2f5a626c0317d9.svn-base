//
//  ZAppStore.m
//  EasyChineseReading-ios
//
//  Created by 赵春阳 on 2017/11/27.
//  Copyright © 2017年 retech. All rights reserved.
//

#import "ZAppStore.h"

#import <StoreKit/StoreKit.h>               //AppStore 支付

@interface ZAppStore ()<SKPaymentTransactionObserver,SKProductsRequestDelegate>

@property (strong, nonatomic) NSString *productsId; //
@property (assign, nonatomic) NSInteger quantity;   //

@property (strong, nonatomic) NSString *currencyCode; // <# #>

@end

@implementation ZAppStore

#pragma mark - 添加观察者

- (void)launch {
    [[SKPaymentQueue defaultQueue] addTransactionObserver:self];
    [self requestProductList];
}

- (void)requestProductList{
    NSLog(@"requestProductList");
}

#pragma mark - 根据商品 id 购买

- (void)buyProductsWithId:(NSString *)productsId andQuantity:(NSInteger)quantity {
    self.productsId = productsId;
    self.quantity = quantity;
    if ([SKPaymentQueue canMakePayments]) {
        //允许程序内付费购买
        [self requestProductData:@[self.productsId]];
    } else {
        //您的手机没有打开程序内付费购买
        ZAlertView *alerView = [[ZAlertView alloc] initWithTitle:LOCALIZATION(@"您的手机没有打开程序内付费购买") message:nil delegate:nil cancelButtonTitle:LOCALIZATION(@"确定") otherButtonTitles:nil];
        [alerView show];
    }
}

// 去苹果服务器请求商品
- (void)requestProductData:(NSArray *)data {
    NSLog(@"-------------请求对应的产品信息----------------");
    NSSet *requestSet = [NSSet setWithArray:data];
    SKProductsRequest *request = [[SKProductsRequest alloc] initWithProductIdentifiers:requestSet];
    request.delegate = self;
    [request start];
}

// SKProductsRequestDelegate 会接收到请求响应，在此回调中，发送购买请求. 收到产品返回信息
- (void)productsRequest:(SKProductsRequest *)request didReceiveResponse:(SKProductsResponse *)response {
    NSLog(@"--------------收到产品反馈消息---------------------");
    NSArray *products = response.products;
    if([products count] == 0){
        NSLog(@"--------------没有商品----------------");
        return;
    }
    
    NSLog(@"productID:%@", response.invalidProductIdentifiers);
    NSLog(@"产品付费数量:%lu",(unsigned long)[products count]);
    
    SKProduct *p = nil;
    for (SKProduct *product in products) {
        NSLog(@"%@", [product description]);
        NSLog(@"%@", [product localizedTitle]);
        NSLog(@"%@", [product localizedDescription]);
        NSLog(@"%@", [product price]);
        NSLog(@"%@", [product productIdentifier]);
        [self updateProductPriceWithId:product.productIdentifier andPrice:product.price];
        if ([[product.priceLocale objectForKey:NSLocaleCurrencyCode] isEqualToString:@"CNY"]) {
            self.currencyCode = @"￥";
        } else {
            self.currencyCode = [product.priceLocale objectForKey:NSLocaleCurrencySymbol];
        }
        
        if([product.productIdentifier isEqualToString:_productsId]){
            p = product;
        }
    }
    if (!p) {
        return;
    }
    SKPayment *payment = [SKPayment paymentWithProduct:p];
    NSLog(@"发送购买请求");
    [[SKPaymentQueue defaultQueue] addPayment:payment];
}

- (void)updateProductPriceWithId:(NSString *)productIdentifier andPrice:(NSDecimalNumber *)price{
    NSLog(@"productIdentifier == %@",productIdentifier);
    NSLog(@"price == %@",price);
}

//请求失败
- (void)request:(SKRequest *)request didFailWithError:(NSError *)error {
    ZAlertView *alerView = [[ZAlertView alloc] initWithTitle:LOCALIZATION(@"支付失败") message:nil delegate:nil cancelButtonTitle:LOCALIZATION(@"确定") otherButtonTitles:nil];
    [alerView show];
    NSLog(@"------------------错误-----------------:%@", error);
}

- (void)requestDidFinish:(SKRequest *)request{
    NSLog(@"------------反馈信息结束-----------------");
}

//监听购买结果
- (void)paymentQueue:(SKPaymentQueue *)queue updatedTransactions:(NSArray *)transaction {
    // 发送到苹果服务器验证凭证
    for(SKPaymentTransaction *tran in transaction){
        switch (tran.transactionState) {
            case SKPaymentTransactionStatePurchased:{
                NSLog(@"交易完成");
                
                [self verifyPurchaseWithPaymentTransaction];
                [[SKPaymentQueue defaultQueue] finishTransaction:tran];
                
            }
                break;
            case SKPaymentTransactionStatePurchasing:
                NSLog(@"商品添加进列表");
                
                break;
            case SKPaymentTransactionStateRestored:{
                NSLog(@"已经购买过商品");
                [[SKPaymentQueue defaultQueue] finishTransaction:tran];
            }
                break;
            case SKPaymentTransactionStateFailed:{
                NSLog(@"支付失败");
                ZAlertView *alerView = [[ZAlertView alloc] initWithTitle:LOCALIZATION(@"购买失败") message:nil delegate:nil cancelButtonTitle:LOCALIZATION(@"确定") otherButtonTitles:nil];
                [alerView show];
                [[SKPaymentQueue defaultQueue] finishTransaction:tran];
//                [self failedTransaction:transaction];
            }
                break;
            default:
                break;
        }
    }
}

#pragma mark - 验证购买

/**
 *  验证购买，避免越狱软件模拟苹果请求达到非法购买问题
 */
- (void)verifyPurchaseWithPaymentTransaction{
    //从沙盒中获取交易凭证并且拼接成请求体数据
    NSURL *receiptUrl = [[NSBundle mainBundle] appStoreReceiptURL];
    NSData *receiptData = [NSData dataWithContentsOfURL:receiptUrl];
    //转化为base64字符串
    NSString *receiptString = [receiptData base64EncodedStringWithOptions:NSDataBase64EncodingEndLineWithLineFeed];
    NSString *bodyString = [NSString stringWithFormat:@"{\"receipt-data\" : \"%@\"}", receiptString];//拼接请求数据
    //再转换为字符串,来发送请求
    NSData *bodyData = [bodyString dataUsingEncoding:NSUTF8StringEncoding];
    
    //创建请求到苹果官方进行购买验证
    NSURL *url = [NSURL URLWithString:SANDBOX];
    NSMutableURLRequest *requestM = [NSMutableURLRequest requestWithURL:url];
    requestM.HTTPBody = bodyData;
    requestM.HTTPMethod = @"POST";
    //创建连接并发送同步请求
    NSError *error = nil;
    NSData *responseData = [NSURLConnection sendSynchronousRequest:requestM returningResponse:nil error:&error];
    if (error) {
        NSLog(@"验证购买过程中发生错误，错误信息：%@",error.localizedDescription);
        return;
    }
    NSDictionary *dic = [NSJSONSerialization JSONObjectWithData:responseData options:NSJSONReadingAllowFragments error:nil];
    NSLog(@"%@",dic);
    if([dic[@"status"] intValue] == 0){
        NSLog(@"购买成功！");
        NSDictionary *dicReceipt = dic[@"receipt"];
        NSDictionary *dicInApp = [dicReceipt[@"in_app"] firstObject];
        NSString *productIdentifier = dicInApp[@"product_id"];//读取产品标识
        //如果是消耗品则记录购买数量，非消耗品则记录是否购买过
        NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];
        if ([productIdentifier isEqualToString:@"123"]) {
            NSInteger purchasedCount = [defaults integerForKey:productIdentifier]; //已购买数量
            [[NSUserDefaults standardUserDefaults] setInteger:(purchasedCount + 1) forKey:productIdentifier];
        }else{
            [defaults setBool:YES forKey:productIdentifier];
        }
        //在此处对购买记录进行存储，可以存储到开发商的服务器端
    }else{
        NSLog(@"购买失败，未通过验证！");
    }
}

- (void)payFinishWithTrinsaction:(SKPaymentTransaction *)transaction state:(NSString *)stateString {
    //如果传了这个参数就完成这个订单的支付
    if (transaction) {
        [[SKPaymentQueue defaultQueue] finishTransaction:transaction];
    }
}

#pragma mark - 交易结束

- (void)completeTransaction:(SKPaymentTransaction *)transaction{
    NSLog(@"交易结束");
    //交易验证
    NSURL *recepitURL = [[NSBundle mainBundle] appStoreReceiptURL];
    NSData *receipt = [NSData dataWithContentsOfURL:recepitURL];
    
    if(!receipt){
        return;
    }
    
    NSError *error;
    NSDictionary *requestContents = @{@"receipt-data": [receipt base64EncodedStringWithOptions:NSDataBase64Encoding64CharacterLineLength]};
    NSData *requestData = [NSJSONSerialization dataWithJSONObject:requestContents options:0  error:&error];
    
    if (!requestData) { /* ... Handle error ... */ }
    
    //In the test environment, use https://sandbox.itunes.apple.com/verifyReceipt
    //In the real environment, use https://buy.itunes.apple.com/verifyReceipt
    // Create a POST request with the receipt data.
    NSURL *storeURL = [NSURL URLWithString:@"https://buy.itunes.apple.com/verifyReceipt"];
    NSMutableURLRequest *storeRequest = [NSMutableURLRequest requestWithURL:storeURL];
    [storeRequest setHTTPMethod:@"POST"];
    [storeRequest setHTTPBody:requestData];
    
    // Make a connection to the iTunes Store on a background queue.
    NSOperationQueue *queue = [[NSOperationQueue alloc] init];
    [NSURLConnection sendAsynchronousRequest:storeRequest queue:queue completionHandler:^(NSURLResponse *response, NSData *data, NSError *connectionError) {
        if (connectionError) {
            /* ... Handle error ... */
        } else {
            NSError *error;
            NSDictionary *jsonResponse = [NSJSONSerialization JSONObjectWithData:data options:0 error:&error];
            if (!jsonResponse) { /* ... Handle error ...*/ }
            /* ... Send a response back to the device ... */
            //Parse the Response
        }
    }];
    [[SKPaymentQueue defaultQueue] finishTransaction:transaction];
}

#pragma mark - 交易成功

//- (void)completeTransaction:(SKPaymentTransaction *)transaction{
//    NSLog(@"-----completeTransaction--------");
//    NSString *product = transaction.payment.productIdentifier;
//    if ([product length] > 0) {
//        NSArray *tt = [product componentsSeparatedByString:@"."];
//        NSString *bookid = [tt lastObject];
//        if ([bookid length] > 0) {
//            [self recordTransaction:bookid];
//            [self provideContent:bookid];}
//    }
//}
//
//- (void)recordTransaction:(NSString *)product{
//    NSLog(@"记录交易--product == %@",product);
//}
//
////处理下载内容
//- (void)provideContent:(NSString *)product{
//    NSLog(@"处理下载内容--product == %@",product);
//}

#pragma mark - 交易失败

- (void)failedTransaction:(SKPaymentTransaction *)transaction{
    NSLog(@"失败");
    if (transaction.error.code != SKErrorPaymentCancelled) { }
    [[SKPaymentQueue defaultQueue] finishTransaction:transaction];
}

#pragma mark - 交易恢复处理

- (void)restoreTransaction:(SKPaymentTransaction *)transaction{
    NSLog(@"交易恢复处理");
}

#pragma mark - 移除观察者

- (void)terminate{
    [[SKPaymentQueue defaultQueue] removeTransactionObserver:self];
}

@end
