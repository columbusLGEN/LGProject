//
//  ECRDownloadStateModel.m
//  downloadStateDemo
//
//  Created by Peanut Lee on 2017/10/12.
//  Copyright © 2017年 Lee. All rights reserved.
//

#import "ECRDownloadStateModel.h"
#import "AFNetworking.h"

//brgess
//book8  - 已完成
//book6 - 未下载

@interface ECRDownloadStateModel ()

/** AFNetworking断点下载（支持离线）需用到的属性 **********/
/** 文件的总长度 */
@property (nonatomic, assign) NSInteger fileLength;
/** 当前下载长度 */
@property (nonatomic, assign) NSInteger currentLength;
/** 文件句柄对象 */
@property (nonatomic, strong) NSFileHandle *fileHandle;

/** 下载任务 */
@property (nonatomic, strong) NSURLSessionDataTask *downloadTask;
/* AFURLSessionManager */
@property (nonatomic, strong) AFURLSessionManager *manager;

@property (copy,nonatomic) ECRDownloadProgressBlock progressBlock;// <##>

@end

@implementation ECRDownloadStateModel
// MARK: TODO list
// TODO: 1 更换正确的 URL
// TODO: 2 更换有效的本地存储路径
// TODO: 3 检测网络状态
#pragma mark 检测网路状态


/**
 * manager的懒加载
 */
- (AFURLSessionManager *)manager {
    if (!_manager) {
        NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration defaultSessionConfiguration];
        // 1. 创建会话管理者
        _manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:configuration];
    }
    return _manager;
}

/**
 * downloadTask的懒加载
 */
/**
需要的"参数"
 1.URL --> 模型自带
 2.本地存储路径 --> 模型自己生成
 3.进度回调block
 */
- (NSURLSessionDataTask *)downloadTask {
    if (!_downloadTask) {
        // TODO:更换正确的 URL
        NSURL *url = [NSURL URLWithString:@"http://dldir1.qq.com/qqfile/QQforMac/QQ_V5.4.0.dmg"];
        
        // 2.创建request请求
        NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url];
        
        // 设置HTTP请求头中的Range
        NSString *range = [NSString stringWithFormat:@"bytes=%zd-", self.currentLength];
        [request setValue:range forHTTPHeaderField:@"Range"];
        
        __weak typeof(self) weakSelf = self;
        _downloadTask = [self.manager dataTaskWithRequest:request completionHandler:^(NSURLResponse * _Nonnull response, id  _Nullable responseObject, NSError * _Nullable error) {
            NSLog(@"dataTaskWithRequest");
            
            // 清空长度
            weakSelf.currentLength = 0;
            weakSelf.fileLength = 0;
            
            // 关闭fileHandle
            [weakSelf.fileHandle closeFile];
            weakSelf.fileHandle = nil;
            
        }];
        
        [self.manager setDataTaskDidReceiveResponseBlock:^NSURLSessionResponseDisposition(NSURLSession * _Nonnull session, NSURLSessionDataTask * _Nonnull dataTask, NSURLResponse * _Nonnull response) {
            NSLog(@"NSURLSessionResponseDisposition");
            
            // 获得下载文件的总长度：请求下载的文件长度 + 当前已经下载的文件长度
            weakSelf.fileLength = response.expectedContentLength + self.currentLength;
            
            // TODO:更换有效的本地存储路径
            NSString *path = [[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject] stringByAppendingPathComponent:@"QQ_V5.4.0.dmg"];
            
            NSLog(@"File downloaded to: %@",path);
            
            // 创建一个空的文件到沙盒中
            NSFileManager *manager = [NSFileManager defaultManager];
            
            if (![manager fileExistsAtPath:path]) {
                // 如果没有下载文件的话，就创建一个文件。如果有下载文件的话，则不用重新创建(不然会覆盖掉之前的文件)
                [manager createFileAtPath:path contents:nil attributes:nil];
            }
            
            // 创建文件句柄
            weakSelf.fileHandle = [NSFileHandle fileHandleForWritingAtPath:path];
            
            // 允许处理服务器的响应，才会继续接收服务器返回的数据
            return NSURLSessionResponseAllow;
        }];
        
        [self.manager setDataTaskDidReceiveDataBlock:^(NSURLSession * _Nonnull session, NSURLSessionDataTask * _Nonnull dataTask, NSData * _Nonnull data) {
//            NSLog(@"setDataTaskDidReceiveDataBlock");
            
            // 指定数据的写入位置 -- 文件内容的最后面
            [weakSelf.fileHandle seekToEndOfFile];
            
            // 向沙盒写入数据
            [weakSelf.fileHandle writeData:data];
            
            // 拼接文件总长度
            weakSelf.currentLength += data.length;
            
            // 获取主线程，不然无法正确显示进度。
            NSOperationQueue* mainQueue = [NSOperationQueue mainQueue];
            [mainQueue addOperationWithBlock:^{
                // TODO: 下载进度
                if (weakSelf.fileLength == 0) {
//                    weakSelf.progressView.progress = 0.0;
//                    weakSelf.progressLabel.text = [NSString stringWithFormat:@"当前下载进度:00.00%%"];
                    if (weakSelf.progressBlock) {
                        weakSelf.progressBlock(0.0);
                    }
                } else {
//                    weakSelf.progressView.progress =  1.0 * weakSelf.currentLength / weakSelf.fileLength;
//                    weakSelf.progressLabel.text = [NSString stringWithFormat:@"当前下载进度:%.2f%%",100.0 * weakSelf.currentLength / weakSelf.fileLength];
                    if (weakSelf.progressBlock) {
                        weakSelf.progressBlock(100.0 * weakSelf.currentLength / weakSelf.fileLength);
                    }
                }
                
            }];
        }];
    }
    return _downloadTask;
}

// MARK: 开始下载
- (void)beginDownload:(ECRDownloadProgressBlock)progressBlock{
    self.progressBlock = progressBlock;
    // 从网络下载
    // http://dldir1.qq.com/qqfile/QQforMac/QQ_V5.4.0.dmg
    // 沙盒文件路径
    NSString *path = [[NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject] stringByAppendingPathComponent:@"QQ_V5.4.0.dmg"];
    
    NSInteger currentLength = [self fileLengthForPath:path];
    if (currentLength > 0) {  // [继续下载]
        self.currentLength = currentLength;
    }
    [self.downloadTask resume];// 正式代码需 打开此行注释
    
    // 暂停（暂时没有暂停功能）
    //    [self.downloadTask suspend];
    //    self.downloadTask = nil;
    
    // 模拟下载，每隔1秒回调 25 50 75 100 四个值
    // TEST
//    CGFloat time = 0.5;
//    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(time * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
//        progressBlock(25.0);
//    });
//    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2*time * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
//        progressBlock(50.0);
//    });
//    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3*time * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
//        progressBlock(75.0);
//    });
//    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(4*time * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
//        progressBlock(100.0);
//    });
}

- (UIImage *)img{
    switch (self.modelState) {
        case ECRDownloadStateModelStateNormal:{
            return [UIImage imageNamed:@"book6"];
        }
            break;
        case ECRDownloadStateModelStateDownloadBegin:{
            return [UIImage imageNamed:@"brgess"];
        }
            break;
        case ECRDownloadStateModelStateDownloading:{
            return [UIImage imageNamed:@"brgess"];
        }
            break;
        case ECRDownloadStateModelStateDownloadFailed:{
            return [UIImage imageNamed:@"book6"];
        }
            break;
        case ECRDownloadStateModelStateDownloaded:{
            return [UIImage imageNamed:@"book8"];
        }
            break;
    }
}

/**
 * 获取已下载的文件大小
 */
- (NSInteger)fileLengthForPath:(NSString *)path {
    NSInteger fileLength = 0;
    NSFileManager *fileManager = [[NSFileManager alloc] init]; // default is not thread safe
    if ([fileManager fileExistsAtPath:path]) {
        NSError *error = nil;
        NSDictionary *fileDict = [fileManager attributesOfItemAtPath:path error:&error];
        if (!error && fileDict) {
            fileLength = [fileDict fileSize];
        }
    }
    return fileLength;
}

@end
